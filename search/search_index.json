{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Google Flights Scraper","text":"<p>Welcome to the <code>google_flights_scraper</code> documentation!</p>"},{"location":"#overview","title":"Overview","text":"<p>This Selenium scraper interacts with Google Flights to select the \"best\" flight options, and collect flight information including prices, times, airlines, connections, and price relativity.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Simple Request Tutorial</li> <li>Batch Request Tutorial</li> <li>API Reference</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>google_flights_scraper<ul> <li>batch_scraper</li> <li>config_browser</li> <li>interactions</li> <li>jupyter_helper</li> <li>parsers</li> <li>scraper</li> <li>validators</li> </ul> </li> </ul>"},{"location":"reference/google_flights_scraper/","title":"google_flights_scraper","text":"<p>A Python-based Selenium scraper for Google Flights.</p>"},{"location":"reference/google_flights_scraper/#google_flights_scraper.GoogleFlightsScraper","title":"<code>GoogleFlightsScraper</code>","text":"<p>Web scraper for Google Flights using Playwright.</p> Source code in <code>src/google_flights_scraper/scraper.py</code> <pre><code>class GoogleFlightsScraper:\n    \"\"\"Web scraper for Google Flights using Playwright.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the scraper with airport codes data.\"\"\"\n        package_dir = Path(__file__).parent.parent.parent\n        csv_path = package_dir / \"data\" / \"airport_codes.csv\"\n        self.airport_codes_df = pd.read_csv(csv_path)\n\n        self.wait_time = DEFAULT_TIMEOUT\n\n        # Playwright instances\n        self.playwright = None\n        self.browser = None\n        self.context = None\n        self.page = None\n\n    @property\n    def _page(self) -&gt; Page:\n        \"\"\"Get page instance, raising error if not initialized.\n\n        Raises:\n            RuntimeError: If browser not initialized.\n        \"\"\"\n        if self.page is None:\n            raise RuntimeError(\"Browser not initialized. Call scrape_flight first.\")\n        return self.page\n\n    def _create_result_structure(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n    ):\n        \"\"\"Create the initial result structure for storing flight data.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country of departure airport or city\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country of arrival airport or city\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class string\n\n        Returns:\n            dict: Empty result structure\n        \"\"\"\n        return {\n            \"inputs\": {\n                \"departure_airport\": departure_code,\n                \"departure_country\": departure_country,\n                \"arrival_airport\": arrival_code,\n                \"arrival_country\": arrival_country,\n                \"departure_date\": start_date,\n                \"return_date\": end_date,\n                \"seat_class\": seat_class,\n            },\n            \"departure_flight\": create_empty_flight_info(),\n            \"return_flight\": create_empty_flight_info(),\n            \"price\": None,\n            \"price_classification\": None,\n            \"price_difference\": None,\n            \"price_relativity\": None,\n            \"status\": None,\n            \"url\": None,\n        }\n\n    def _validate_inputs(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        seat_class: str,\n        start_date: str,\n        end_date: str,\n        export_path: str | None,\n    ):\n        \"\"\"Validate all input parameters.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country for departure airport\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country for arrival airport\n            seat_class (str): Seat class string\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            export_path (str | None): Path to export file\n\n        Returns:\n            bool: True if flight is domestic US\n        \"\"\"\n        for code in [departure_code, arrival_code]:\n            validate_airport_code(code, self.airport_codes_df)\n\n        is_domestic_us = is_domestic_us_flight(\n            departure_country,\n            arrival_country,\n            self.airport_codes_df,\n        )\n\n        validate_seat_class(seat_class, is_domestic_us)\n        validate_dates(start_date, end_date)\n        validate_export_params(export_path)\n\n        return is_domestic_us\n\n    async def _fill_search_form(\n        self,\n        departure_code: str,\n        arrival_code: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n        is_domestic_us: bool,\n    ):\n        \"\"\"Fill out the Google Flights search form.\n\n        Args:\n            departure_code (str): IATA code for departure airport\n            arrival_code (str): IATA code for arrival airport\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class string\n            is_domestic_us (bool): Whether flight is domestic US\n        \"\"\"\n        await enter_airports(self._page, departure_code, arrival_code)\n        await enter_dates(self._page, start_date, end_date)\n        await select_seat_class(self._page, seat_class, is_domestic_us)\n        await press_search_button(self._page)\n\n    async def _find_flight_with_retry(\n        self,\n        result: dict,\n        key: str,\n        max_retries: int = 3,\n        sleep_s: float = 0.5,\n    ):\n        \"\"\"Find best flight element with retry and extract details.\n\n        Args:\n            result (dict): Dictionary to populate with flight details\n            key (str): Dict key to add data to (departure_flight or return_flight)\n            max_retries (int): Number of times to retry selecting element\n            sleep_s (float): How long to sleep (seconds) in between each try\n\n        Returns:\n            str | None: Error message if failed, None if successful\n        \"\"\"\n        for attempt in range(max_retries):\n            try:\n                flight = await find_and_select_best_flight(self._page, timeout=self.wait_time)\n\n                if flight is None:\n                    return f\"No {key.replace('_', ' ')} found.\"\n\n                result[key] = await extract_flight_details(flight)\n\n                await flight.click()\n                return None\n\n            except Exception as e:\n                if attempt == max_retries - 1:\n                    return f\"Error finding {key}: {str(e)}\"\n                await asyncio.sleep(sleep_s)\n\n        return f\"Failed to find {key} after {max_retries} retries.\"\n\n    async def _select_best_flights(self, result: dict):\n        \"\"\"Select the best departure and return flights and extract details.\n\n        Args:\n            result (dict): Dictionary to populate with flight details\n\n        Returns:\n            tuple: (updated result dictionary, success status message)\n        \"\"\"\n        err = await self._find_flight_with_retry(result, key=\"departure_flight\")\n        if err:\n            return result, err\n\n        err = await self._find_flight_with_retry(result, key=\"return_flight\")\n        if err:\n            return result, err\n\n        await asyncio.sleep(1)\n\n        result[\"price\"] = await extract_final_price(self._page, timeout=self.wait_time * 2)\n\n        if result[\"price\"] is None:\n            return result, \"Error: Price not found\"\n\n        result[\"url\"] = self._page.url\n\n        return result, \"Ran successfully.\"\n\n    def _calc_price_rel(self, price: int, price_difference: int | None):\n        \"\"\"Calculate price relativity (% discount).\n\n        Args:\n            price (int): Final flight price\n            price_difference (int | None): How much cheaper flight is than usual\n\n        Returns:\n            float | None: Percentage discount or None\n        \"\"\"\n        if price_difference is not None and price is not None:\n            return round(float(price_difference / (price + price_difference)), 4)\n        return None\n\n    def _export_data(self, result: dict, export_path: str):\n        \"\"\"Export dict to file based on extension.\n\n        Args:\n            result (dict): Resulting dictionary after scraping\n            export_path (str): Path to export file to\n        \"\"\"\n        if export_path.endswith(\".json\"):\n            with open(export_path, \"w\") as f:\n                f.write(json.dumps(result, indent=2))\n        elif export_path.endswith(\".csv\"):\n            df = pd.json_normalize(result, sep=\"_\")\n            df.to_csv(export_path, index=False)\n\n    async def scrape_flight(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n        export_path: str | None = None,\n    ):\n        \"\"\"Scrape Google Flights for specified route and parameters.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country for departure airport\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country for arrival airport\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)\n            export_path (str | None): Path to export file (.json or .csv)\n\n        Returns:\n            dict: Complete flight information as dictionary\n        \"\"\"\n        result = self._create_result_structure(\n            departure_code,\n            departure_country,\n            arrival_code,\n            arrival_country,\n            start_date,\n            end_date,\n            seat_class,\n        )\n\n        try:\n            is_domestic_us = self._validate_inputs(\n                departure_code,\n                departure_country,\n                arrival_code,\n                arrival_country,\n                seat_class,\n                start_date,\n                end_date,\n                export_path,\n            )\n\n            self.playwright, self.browser, self.context, self.page = await setup_browser()\n\n            await self.page.goto(\"https://www.google.com/travel/flights\")\n\n            await self._fill_search_form(\n                departure_code,\n                arrival_code,\n                start_date,\n                end_date,\n                seat_class,\n                is_domestic_us,\n            )\n\n            result, status = await self._select_best_flights(result)\n\n            if status == \"Ran successfully.\":\n                (\n                    result[\"price_classification\"],\n                    result[\"price_difference\"],\n                ) = await extract_price_relativity(self.page, timeout=2000)\n\n            result[\"price_relativity\"] = self._calc_price_rel(\n                result[\"price\"], result[\"price_difference\"]\n            )\n\n        except Exception as e:\n            print(f\"Error scraping flight: {e}\", file=sys.stderr)\n            status = f\"Error: {str(e)}\"\n        finally:\n            if self.page:\n                await self.page.close()\n            if self.context:\n                await self.context.close()\n            if self.browser:\n                await self.browser.close()\n            if self.playwright:\n                await self.playwright.stop()\n\n        result[\"status\"] = status\n\n        if export_path:\n            self._export_data(result, export_path)\n\n        return result\n</code></pre>"},{"location":"reference/google_flights_scraper/#google_flights_scraper.GoogleFlightsScraper.scrape_flight","title":"<code>scrape_flight(departure_code, departure_country, arrival_code, arrival_country, start_date, end_date, seat_class, export_path=None)</code>  <code>async</code>","text":"<p>Scrape Google Flights for specified route and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_code</code> <code>str</code> <p>IATA code or city for arrival airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <code>seat_class</code> <code>str</code> <p>Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)</p> required <code>export_path</code> <code>str | None</code> <p>Path to export file (.json or .csv)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Complete flight information as dictionary</p> Source code in <code>src/google_flights_scraper/scraper.py</code> <pre><code>async def scrape_flight(\n    self,\n    departure_code: str,\n    departure_country: str,\n    arrival_code: str,\n    arrival_country: str,\n    start_date: str,\n    end_date: str,\n    seat_class: str,\n    export_path: str | None = None,\n):\n    \"\"\"Scrape Google Flights for specified route and parameters.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_code (str): IATA code or city for arrival airport\n        arrival_country (str): Country for arrival airport\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n        seat_class (str): Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)\n        export_path (str | None): Path to export file (.json or .csv)\n\n    Returns:\n        dict: Complete flight information as dictionary\n    \"\"\"\n    result = self._create_result_structure(\n        departure_code,\n        departure_country,\n        arrival_code,\n        arrival_country,\n        start_date,\n        end_date,\n        seat_class,\n    )\n\n    try:\n        is_domestic_us = self._validate_inputs(\n            departure_code,\n            departure_country,\n            arrival_code,\n            arrival_country,\n            seat_class,\n            start_date,\n            end_date,\n            export_path,\n        )\n\n        self.playwright, self.browser, self.context, self.page = await setup_browser()\n\n        await self.page.goto(\"https://www.google.com/travel/flights\")\n\n        await self._fill_search_form(\n            departure_code,\n            arrival_code,\n            start_date,\n            end_date,\n            seat_class,\n            is_domestic_us,\n        )\n\n        result, status = await self._select_best_flights(result)\n\n        if status == \"Ran successfully.\":\n            (\n                result[\"price_classification\"],\n                result[\"price_difference\"],\n            ) = await extract_price_relativity(self.page, timeout=2000)\n\n        result[\"price_relativity\"] = self._calc_price_rel(\n            result[\"price\"], result[\"price_difference\"]\n        )\n\n    except Exception as e:\n        print(f\"Error scraping flight: {e}\", file=sys.stderr)\n        status = f\"Error: {str(e)}\"\n    finally:\n        if self.page:\n            await self.page.close()\n        if self.context:\n            await self.context.close()\n        if self.browser:\n            await self.browser.close()\n        if self.playwright:\n            await self.playwright.stop()\n\n    result[\"status\"] = status\n\n    if export_path:\n        self._export_data(result, export_path)\n\n    return result\n</code></pre>"},{"location":"reference/google_flights_scraper/batch_scraper/","title":"batch_scraper","text":"<p>Batch scraping functions for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/batch_scraper/#google_flights_scraper.batch_scraper.scrape_date_range","title":"<code>scrape_date_range(departure_code, departure_country, arrival_code, arrival_country, start_date_range, end_date_range, min_trip_length, max_trip_length, seat_class, output_path=None, delay_seconds=3.0, delay_jitter=0.5, n_jobs=1, task_timeout=DEFAULT_TASK_TIMEOUT)</code>  <code>async</code>","text":"<p>Scrape all date combinations within a date range.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_code</code> <code>str</code> <p>IATA code or city for arrival airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>start_date_range</code> <code>str</code> <p>Earliest departure date in MM/DD/YYYY format</p> required <code>end_date_range</code> <code>str</code> <p>Latest possible return date in MM/DD/YYYY format</p> required <code>min_trip_length</code> <code>int</code> <p>Minimum trip length in days</p> required <code>max_trip_length</code> <code>int</code> <p>Maximum trip length in days</p> required <code>seat_class</code> <code>str</code> <p>Seat class</p> required <code>output_path</code> <code>str | None</code> <p>Optional path to save CSV output</p> <code>None</code> <code>delay_seconds</code> <code>float</code> <p>Base delay between searches in seconds when n_jobs=1 (default 3.0)</p> <code>3.0</code> <code>delay_jitter</code> <code>float</code> <p>Max random \u00b1 jitter applied to delay_seconds (default 0.5).</p> <code>0.5</code> <code>n_jobs</code> <code>int</code> <p>Number of concurrent scrapes (default 1). When &gt;1, delay_seconds           is ignored and concurrency is controlled by the semaphore.</p> <code>1</code> <code>task_timeout</code> <code>int</code> <p>Max seconds to wait for a single scrape before cancelling (default 120).</p> <code>DEFAULT_TASK_TIMEOUT</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Results for all date combinations</p> Source code in <code>src/google_flights_scraper/batch_scraper.py</code> <pre><code>async def scrape_date_range(\n    departure_code: str,\n    departure_country: str,\n    arrival_code: str,\n    arrival_country: str,\n    start_date_range: str,\n    end_date_range: str,\n    min_trip_length: int,\n    max_trip_length: int,\n    seat_class: str,\n    output_path: str | None = None,\n    delay_seconds: float = 3.0,\n    delay_jitter: float = 0.5,\n    n_jobs: int = 1,\n    task_timeout: int = DEFAULT_TASK_TIMEOUT,\n):\n    \"\"\"Scrape all date combinations within a date range.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_code (str): IATA code or city for arrival airport\n        arrival_country (str): Country for arrival airport\n        start_date_range (str): Earliest departure date in MM/DD/YYYY format\n        end_date_range (str): Latest possible return date in MM/DD/YYYY format\n        min_trip_length (int): Minimum trip length in days\n        max_trip_length (int): Maximum trip length in days\n        seat_class (str): Seat class\n        output_path (str | None): Optional path to save CSV output\n        delay_seconds (float): Base delay between searches in seconds when n_jobs=1 (default 3.0)\n        delay_jitter (float): Max random \u00b1 jitter applied to delay_seconds (default 0.5).\n        n_jobs (int): Number of concurrent scrapes (default 1). When &gt;1, delay_seconds\n                      is ignored and concurrency is controlled by the semaphore.\n        task_timeout (int): Max seconds to wait for a single scrape before cancelling (default 120).\n\n    Returns:\n        DataFrame: Results for all date combinations\n    \"\"\"\n    start_range = datetime.strptime(start_date_range, \"%m/%d/%Y\")\n    end_range = datetime.strptime(end_date_range, \"%m/%d/%Y\")\n\n    date_combinations = []\n    current_departure = start_range\n\n    while current_departure &lt;= end_range:\n        for trip_length in range(min_trip_length, max_trip_length + 1):\n            return_date = current_departure + timedelta(days=trip_length)\n            if return_date &lt;= end_range:\n                date_combinations.append({\n                    \"departure\": current_departure.strftime(\"%m/%d/%Y\"),\n                    \"return\": return_date.strftime(\"%m/%d/%Y\"),\n                    \"trip_length\": trip_length,\n                })\n        current_departure += timedelta(days=1)\n\n    tasks = [\n        {\n            \"departure_code\": departure_code,\n            \"departure_country\": departure_country,\n            \"arrival_code\": arrival_code,\n            \"arrival_country\": arrival_country,\n            \"start_date\": combo[\"departure\"],\n            \"end_date\": combo[\"return\"],\n            \"seat_class\": seat_class,\n            \"trip_length\": combo[\"trip_length\"],\n        }\n        for combo in date_combinations\n    ]\n\n    results = await _run_tasks(\n        tasks,\n        delay_seconds=delay_seconds,\n        delay_jitter=delay_jitter,\n        n_jobs=n_jobs,\n        task_timeout=task_timeout,\n    )\n\n    df = pd.DataFrame(results)\n\n    if \"price_relativity\" in df.columns:\n        df = df.sort_values(\"price_relativity\", ascending=False, na_position=\"last\")\n\n    if output_path:\n        df.to_csv(output_path, index=False)\n\n    return df\n</code></pre>"},{"location":"reference/google_flights_scraper/batch_scraper/#google_flights_scraper.batch_scraper.scrape_multiple_destinations","title":"<code>scrape_multiple_destinations(departure_code, departure_country, arrival_codes, arrival_countries, start_date, end_date, seat_classes, output_path=None, delay_seconds=3.0, delay_jitter=0.5, n_jobs=1, task_timeout=DEFAULT_TASK_TIMEOUT)</code>  <code>async</code>","text":"<p>Scrape multiple destinations with fixed dates.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_codes</code> <code>list[str]</code> <p>List of IATA codes or cities for arrival airports</p> required <code>arrival_countries</code> <code>list[str]</code> <p>List of countries (same length as arrival_codes)</p> required <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <code>seat_classes</code> <code>list[str]</code> <p>List of seat classes (same length as arrival_codes)</p> required <code>output_path</code> <code>str | None</code> <p>Optional path to save CSV output</p> <code>None</code> <code>delay_seconds</code> <code>float</code> <p>Base delay between searches in seconds when n_jobs=1 (default 3.0)</p> <code>3.0</code> <code>delay_jitter</code> <code>float</code> <p>Max random \u00b1 jitter applied to delay_seconds (default 0.5).</p> <code>0.5</code> <code>n_jobs</code> <code>int</code> <p>Number of concurrent scrapes (default 1). When &gt;1, delay_seconds           is ignored and concurrency is controlled by the semaphore.</p> <code>1</code> <code>task_timeout</code> <code>int</code> <p>Max seconds to wait for a single scrape before cancelling (default 120).</p> <code>DEFAULT_TASK_TIMEOUT</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Results for all destinations</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If arrival_codes, arrival_countries, and seat_classes are not the same length</p> Source code in <code>src/google_flights_scraper/batch_scraper.py</code> <pre><code>async def scrape_multiple_destinations(\n    departure_code: str,\n    departure_country: str,\n    arrival_codes: list[str],\n    arrival_countries: list[str],\n    start_date: str,\n    end_date: str,\n    seat_classes: list[str],\n    output_path: str | None = None,\n    delay_seconds: float = 3.0,\n    delay_jitter: float = 0.5,\n    n_jobs: int = 1,\n    task_timeout: int = DEFAULT_TASK_TIMEOUT,\n):\n    \"\"\"Scrape multiple destinations with fixed dates.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_codes (list[str]): List of IATA codes or cities for arrival airports\n        arrival_countries (list[str]): List of countries (same length as arrival_codes)\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n        seat_classes (list[str]): List of seat classes (same length as arrival_codes)\n        output_path (str | None): Optional path to save CSV output\n        delay_seconds (float): Base delay between searches in seconds when n_jobs=1 (default 3.0)\n        delay_jitter (float): Max random \u00b1 jitter applied to delay_seconds (default 0.5).\n        n_jobs (int): Number of concurrent scrapes (default 1). When &gt;1, delay_seconds\n                      is ignored and concurrency is controlled by the semaphore.\n        task_timeout (int): Max seconds to wait for a single scrape before cancelling (default 120).\n\n    Returns:\n        DataFrame: Results for all destinations\n\n    Raises:\n        ValueError: If arrival_codes, arrival_countries, and seat_classes are not the same length\n    \"\"\"\n    if len(arrival_codes) != len(arrival_countries):\n        raise ValueError(\"arrival_codes and arrival_countries must have same length\")\n\n    if len(arrival_codes) != len(seat_classes):\n        raise ValueError(\"arrival_codes and seat_classes must have same length\")\n\n    tasks = [\n        {\n            \"departure_code\": departure_code,\n            \"departure_country\": departure_country,\n            \"arrival_code\": arrival_code,\n            \"arrival_country\": arrival_country,\n            \"start_date\": start_date,\n            \"end_date\": end_date,\n            \"seat_class\": seat_class,\n        }\n        for arrival_code, arrival_country, seat_class in zip(\n            arrival_codes, arrival_countries, seat_classes, strict=True\n        )\n    ]\n\n    results = await _run_tasks(\n        tasks,\n        delay_seconds=delay_seconds,\n        delay_jitter=delay_jitter,\n        n_jobs=n_jobs,\n        task_timeout=task_timeout,\n    )\n\n    df = pd.DataFrame(results)\n\n    if \"price_relativity\" in df.columns:\n        df = df.sort_values(\"price_relativity\", ascending=False, na_position=\"last\")\n\n    if output_path:\n        df.to_csv(output_path, index=False)\n\n    return df\n</code></pre>"},{"location":"reference/google_flights_scraper/config_browser/","title":"config_browser","text":"<p>Configuration constants and browser setup for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/config_browser/#google_flights_scraper.config_browser.get_random_user_agent","title":"<code>get_random_user_agent()</code>","text":"<p>Return a random user agent string from the pool.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A randomly selected user agent string</p> Source code in <code>src/google_flights_scraper/config_browser.py</code> <pre><code>def get_random_user_agent() -&gt; str:\n    \"\"\"Return a random user agent string from the pool.\n\n    Returns:\n        str: A randomly selected user agent string\n    \"\"\"\n    return random.choice(USER_AGENTS)\n</code></pre>"},{"location":"reference/google_flights_scraper/config_browser/#google_flights_scraper.config_browser.setup_browser","title":"<code>setup_browser()</code>  <code>async</code>","text":"<p>Setup Playwright browser with appropriate options and a randomized user agent.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Playwright, Browser, BrowserContext, Page]</code> <p>(playwright instance, browser, context, page)</p> Source code in <code>src/google_flights_scraper/config_browser.py</code> <pre><code>async def setup_browser() -&gt; tuple[Playwright, Browser, BrowserContext, Page]:\n    \"\"\"Setup Playwright browser with appropriate options and a randomized user agent.\n\n    Returns:\n        tuple: (playwright instance, browser, context, page)\n    \"\"\"\n    playwright = await async_playwright().start()\n\n    browser = await playwright.chromium.launch(\n        headless=True,\n        args=[\n            \"--no-sandbox\",\n            \"--disable-dev-shm-usage\",\n            \"--disable-blink-features=AutomationControlled\",\n            \"--disable-gpu\",\n            \"--start-maximized\",\n        ],\n    )\n\n    context = await browser.new_context(\n        no_viewport=True,\n        user_agent=get_random_user_agent(),\n    )\n\n    # Block images, fonts, media to speed up\n    await context.route(\n        \"**/*.{png,jpg,jpeg,gif,svg,woff,woff2,mp4,webm}\", lambda route: route.abort()\n    )\n    # Block analytics\n    await context.route(\"**/analytics.google.com/**\", lambda route: route.abort())\n    await context.route(\"**/googletagmanager.com/**\", lambda route: route.abort())\n\n    page = await context.new_page()\n    page.set_default_timeout(DEFAULT_TIMEOUT)\n\n    return playwright, browser, context, page\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/","title":"interactions","text":"<p>Page interaction functions for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_airports","title":"<code>enter_airports(page, airport_code_from, airport_code_to)</code>  <code>async</code>","text":"<p>Enter both departure and arrival airport codes.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>airport_code_from</code> <code>str</code> <p>IATA code for departure airport</p> required <code>airport_code_to</code> <code>str</code> <p>IATA code for arrival airport</p> required Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def enter_airports(page: Page, airport_code_from: str, airport_code_to: str):\n    \"\"\"Enter both departure and arrival airport codes.\n\n    Args:\n        page (Page): Playwright Page instance\n        airport_code_from (str): IATA code for departure airport\n        airport_code_to (str): IATA code for arrival airport\n    \"\"\"\n    await enter_departure_airport(page, airport_code_from)\n    await enter_arrival_airport(page, airport_code_to)\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_arrival_airport","title":"<code>enter_arrival_airport(page, airport_code)</code>  <code>async</code>","text":"<p>Enter arrival airport code into input field.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>airport_code</code> <code>str</code> <p>IATA code for arrival airport</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def enter_arrival_airport(page: Page, airport_code: str):\n    \"\"\"Enter arrival airport code into input field.\n\n    Args:\n        page (Page): Playwright Page instance\n        airport_code (str): IATA code for arrival airport\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        to_input = page.locator(\"input[aria-label='Where to? ']\")\n        await to_input.wait_for(state=\"visible\")\n        await to_input.click()\n\n        to_popup = page.locator(\"input[aria-label*='Where to?']\").nth(1)\n        await to_popup.wait_for(state=\"visible\")\n        await to_popup.clear()\n        await to_popup.fill(airport_code)\n        await to_popup.press(\"ArrowDown\")\n        await to_popup.press(\"Enter\")\n    except PlaywrightTimeoutError as e:\n        raise Exception(\"Error entering arrival airport:\") from e\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_dates","title":"<code>enter_dates(page, date_from, date_to)</code>  <code>async</code>","text":"<p>Enter both departure and return dates.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>date_from</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>date_to</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def enter_dates(page: Page, date_from: str, date_to: str):\n    \"\"\"Enter both departure and return dates.\n\n    Args:\n        page (Page): Playwright Page instance\n        date_from (str): Departure date in MM/DD/YYYY format\n        date_to (str): Return date in MM/DD/YYYY format\n    \"\"\"\n    await enter_departure_date(page, date_from)\n    await enter_return_date(page, date_to)\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_departure_airport","title":"<code>enter_departure_airport(page, airport_code)</code>  <code>async</code>","text":"<p>Enter departure airport code into input field.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>airport_code</code> <code>str</code> <p>IATA code for departure airport</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def enter_departure_airport(page: Page, airport_code: str):\n    \"\"\"Enter departure airport code into input field.\n\n    Args:\n        page (Page): Playwright Page instance\n        airport_code (str): IATA code for departure airport\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        from_input = page.locator(\"input[aria-label='Where from?']\")\n        await from_input.wait_for(state=\"visible\")\n        await from_input.click()\n        await asyncio.sleep(1)\n\n        from_popup = page.locator(\"input[aria-label*='Where else?']\").nth(1)\n        await from_popup.wait_for(state=\"visible\")\n        await from_popup.clear()\n        await from_popup.fill(airport_code)\n        await from_popup.press(\"ArrowDown\")\n        await from_popup.press(\"Enter\")\n    except PlaywrightTimeoutError as e:\n        raise Exception(\"Error entering departure airport:\") from e\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_departure_date","title":"<code>enter_departure_date(page, date_from)</code>  <code>async</code>","text":"<p>Enter departure date into input field.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>date_from</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def enter_departure_date(page: Page, date_from: str):\n    \"\"\"Enter departure date into input field.\n\n    Args:\n        page (Page): Playwright Page instance\n        date_from (str): Departure date in MM/DD/YYYY format\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        departure_input = page.locator(\"input[aria-label='Departure']\").first\n        await departure_input.wait_for(state=\"visible\")\n        await departure_input.click()\n        await asyncio.sleep(1)\n\n        departure_popup = page.locator(\"input[aria-label='Departure']\").nth(1)\n        await departure_popup.wait_for(state=\"visible\")\n        await departure_popup.fill(date_from)\n    except PlaywrightTimeoutError as e:\n        raise Exception(\"Error entering departure date:\") from e\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_return_date","title":"<code>enter_return_date(page, date_to)</code>  <code>async</code>","text":"<p>Enter return date into input field.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>date_to</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def enter_return_date(page: Page, date_to: str):\n    \"\"\"Enter return date into input field.\n\n    Args:\n        page (Page): Playwright Page instance\n        date_to (str): Return date in MM/DD/YYYY format\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        return_popup = page.locator(\"input[aria-label='Return']\").nth(1)\n        await return_popup.wait_for(state=\"visible\")\n        await return_popup.fill(date_to)\n        await return_popup.press(\"Enter\")\n        await return_popup.press(\"Enter\")\n    except PlaywrightTimeoutError as e:\n        raise Exception(\"Error entering return date:\") from e\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.find_and_select_best_flight","title":"<code>find_and_select_best_flight(page, timeout)</code>  <code>async</code>","text":"<p>Find and return the best (first) flight option on the page.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>timeout</code> <code>int</code> <p>Timeout in milliseconds for waiting operations</p> required <p>Returns:</p> Name Type Description <code>Locator</code> <p>The best flight element locator, or None if not found</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def find_and_select_best_flight(page: Page, timeout: int):\n    \"\"\"Find and return the best (first) flight option on the page.\n\n    Args:\n        page (Page): Playwright Page instance\n        timeout (int): Timeout in milliseconds for waiting operations\n\n    Returns:\n        Locator: The best flight element locator, or None if not found\n    \"\"\"\n    # Wait for page to fully load\n    await wait_until_stable(\n        page,\n        \"div[role='progressbar']\",\n        stable_duration=2.0,\n        timeout=timeout,\n    )\n\n    # Find best flight (first option)\n    try:\n        best_flight = page.locator(\"ul[role='list']\").nth(1).locator(\"li\").nth(0)\n        return best_flight\n    except PlaywrightTimeoutError:\n        return None\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.press_search_button","title":"<code>press_search_button(page)</code>  <code>async</code>","text":"<p>Press the search button to initiate flight search.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If search button cannot be found or clicked</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def press_search_button(page: Page):\n    \"\"\"Press the search button to initiate flight search.\n\n    Args:\n        page (Page): Playwright Page instance\n\n    Raises:\n        Exception: If search button cannot be found or clicked\n    \"\"\"\n    try:\n        search_button = page.locator(\"button[aria-label='Search']\")\n        await search_button.wait_for(state=\"visible\")\n        await search_button.click()\n    except PlaywrightTimeoutError as e:\n        raise Exception(\"Error pressing search button:\") from e\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.select_seat_class","title":"<code>select_seat_class(page, seat_class, is_domestic_us)</code>  <code>async</code>","text":"<p>Select seat class from dropdown.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>seat_class</code> <code>str</code> <p>Seat class to select</p> required <code>is_domestic_us</code> <code>bool</code> <p>Whether flight is domestic US</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def select_seat_class(page: Page, seat_class: str, is_domestic_us: bool):\n    \"\"\"Select seat class from dropdown.\n\n    Args:\n        page (Page): Playwright Page instance\n        seat_class (str): Seat class to select\n        is_domestic_us (bool): Whether flight is domestic US\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        class_dropdown = page.locator(\n            \"div[role='combobox']:has(span[aria-label='Change seating class.'])\"\n        )\n        await class_dropdown.wait_for(state=\"visible\")\n        await class_dropdown.click()\n\n        # Get all options\n        listbox = page.locator(\"ul[role='listbox']\").nth(1)\n        await listbox.wait_for(state=\"visible\")\n\n        # Select correct option\n        class_options = page.locator(\"ul[role='listbox']\").nth(1).locator(\"li[role='option']\")\n        option_index = SEAT_CLASS_OPTION_MAPPING[is_domestic_us][seat_class.lower()]\n        await class_options.nth(option_index).wait_for(state=\"visible\")\n        await class_options.nth(option_index).click()\n    except PlaywrightTimeoutError as e:\n        raise Exception(\"Error selecting seat class:\") from e\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.wait_until_stable","title":"<code>wait_until_stable(page, selector, stable_duration=2.0, timeout=10000)</code>  <code>async</code>","text":"<p>Wait until an element's class attribute stops changing.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>selector</code> <code>str</code> <p>CSS selector for the element</p> required <code>stable_duration</code> <code>float</code> <p>How long (in seconds) the class must remain unchanged</p> <code>2.0</code> <code>timeout</code> <code>int</code> <p>Maximum time to wait in milliseconds before raising TimeoutError</p> <code>10000</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If element class does not stabilize within timeout</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>async def wait_until_stable(\n    page: Page, selector: str, stable_duration: float = 2.0, timeout: int = 10000\n):\n    \"\"\"Wait until an element's class attribute stops changing.\n\n    Args:\n        page (Page): Playwright Page instance\n        selector (str): CSS selector for the element\n        stable_duration (float): How long (in seconds) the class must remain unchanged\n        timeout (int): Maximum time to wait in milliseconds before raising TimeoutError\n\n    Raises:\n        TimeoutError: If element class does not stabilize within timeout\n    \"\"\"\n    import time\n\n    start_time = time.time()\n    timeout_seconds = timeout / 1000\n    previous_class = None\n    first_read = True\n    stable_since = None\n\n    while True:\n        if time.time() - start_time &gt; timeout_seconds:\n            raise TimeoutError(f\"Element class did not stabilize within {timeout}ms\")\n\n        try:\n            element = page.locator(selector).nth(0)\n\n            # Wait for element to exist\n            if await element.count() == 0:\n                first_read = True\n                previous_class = None\n                stable_since = None\n                await asyncio.sleep(0.1)\n                continue\n\n            current_class = await element.get_attribute(\"class\")\n\n            # On first read, just store the class\n            if first_read:\n                previous_class = current_class\n                stable_since = time.time()\n                first_read = False\n            elif current_class == previous_class:\n                if stable_since is not None:\n                    if time.time() - stable_since &gt;= stable_duration:\n                        await asyncio.sleep(1)\n                        break\n            else:\n                # Class changed, reset the timer\n                previous_class = current_class\n                stable_since = time.time()\n\n            await asyncio.sleep(0.1)  # Check every 100ms\n\n        except Exception:\n            # Element not found yet, keep waiting\n            first_read = True\n            previous_class = None\n            stable_since = None\n            await asyncio.sleep(0.1)\n</code></pre>"},{"location":"reference/google_flights_scraper/jupyter_helper/","title":"jupyter_helper","text":"<p>Helper for running scraper from Jupyter notebooks.</p>"},{"location":"reference/google_flights_scraper/jupyter_helper/#google_flights_scraper.jupyter_helper.scrape_date_range","title":"<code>scrape_date_range(departure_code, departure_country, arrival_code, arrival_country, start_date_range, end_date_range, min_trip_length, max_trip_length, seat_class, output_path=None, delay_seconds=3.0, n_jobs=1)</code>","text":"<p>Scrape date range in subprocess to avoid asyncio conflicts with Jupyter.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_code</code> <code>str</code> <p>IATA code or city for arrival airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>start_date_range</code> <code>str</code> <p>Earliest departure date in MM/DD/YYYY format</p> required <code>end_date_range</code> <code>str</code> <p>Latest possible return date in MM/DD/YYYY format</p> required <code>min_trip_length</code> <code>int</code> <p>Minimum trip length in days</p> required <code>max_trip_length</code> <code>int</code> <p>Maximum trip length in days</p> required <code>seat_class</code> <code>str</code> <p>Seat class</p> required <code>output_path</code> <code>str | None</code> <p>Optional path to save CSV output</p> <code>None</code> <code>delay_seconds</code> <code>float</code> <p>Delay between searches in seconds when n_jobs=1</p> <code>3.0</code> <code>n_jobs</code> <code>int</code> <p>Number of concurrent scrapes (default 1)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Results for all date combinations</p> Source code in <code>src/google_flights_scraper/jupyter_helper.py</code> <pre><code>def scrape_date_range(\n    departure_code: str,\n    departure_country: str,\n    arrival_code: str,\n    arrival_country: str,\n    start_date_range: str,\n    end_date_range: str,\n    min_trip_length: int,\n    max_trip_length: int,\n    seat_class: str,\n    output_path: str | None = None,\n    delay_seconds: float = 3.0,\n    n_jobs: int = 1,\n):\n    \"\"\"Scrape date range in subprocess to avoid asyncio conflicts with Jupyter.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_code (str): IATA code or city for arrival airport\n        arrival_country (str): Country for arrival airport\n        start_date_range (str): Earliest departure date in MM/DD/YYYY format\n        end_date_range (str): Latest possible return date in MM/DD/YYYY format\n        min_trip_length (int): Minimum trip length in days\n        max_trip_length (int): Maximum trip length in days\n        seat_class (str): Seat class\n        output_path (str | None): Optional path to save CSV output\n        delay_seconds (float): Delay between searches in seconds when n_jobs=1\n        n_jobs (int): Number of concurrent scrapes (default 1)\n\n    Returns:\n        DataFrame: Results for all date combinations\n    \"\"\"\n    script = f\"\"\"\nimport asyncio\nimport json\nfrom google_flights_scraper.batch_scraper import scrape_date_range\n\nasync def main():\n    df = await scrape_date_range(\n        departure_code=\"{departure_code}\",\n        departure_country=\"{departure_country}\",\n        arrival_code=\"{arrival_code}\",\n        arrival_country=\"{arrival_country}\",\n        start_date_range=\"{start_date_range}\",\n        end_date_range=\"{end_date_range}\",\n        min_trip_length={min_trip_length},\n        max_trip_length={max_trip_length},\n        seat_class=\"{seat_class}\",\n        output_path={f'\"{output_path}\"' if output_path else \"None\"},\n        delay_seconds={delay_seconds},\n        n_jobs={n_jobs}\n    )\n    print(df.to_json(orient='records'))\n\nasyncio.run(main())\n\"\"\"\n    import pandas as pd\n\n    data = _run_script(script)\n    return pd.DataFrame(data)\n</code></pre>"},{"location":"reference/google_flights_scraper/jupyter_helper/#google_flights_scraper.jupyter_helper.scrape_flight","title":"<code>scrape_flight(departure_code, departure_country, arrival_code, arrival_country, start_date, end_date, seat_class, export_path=None)</code>","text":"<p>Run flight scraper in subprocess to avoid asyncio conflicts with Jupyter.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_code</code> <code>str</code> <p>IATA code or city for arrival airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <code>seat_class</code> <code>str</code> <p>Seat class (e.g., \"Economy (include Basic)\")</p> required <code>export_path</code> <code>str | None</code> <p>Optional path to export results (.json or .csv)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Flight scraping results</p> Source code in <code>src/google_flights_scraper/jupyter_helper.py</code> <pre><code>def scrape_flight(\n    departure_code: str,\n    departure_country: str,\n    arrival_code: str,\n    arrival_country: str,\n    start_date: str,\n    end_date: str,\n    seat_class: str,\n    export_path: str | None = None,\n):\n    \"\"\"Run flight scraper in subprocess to avoid asyncio conflicts with Jupyter.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_code (str): IATA code or city for arrival airport\n        arrival_country (str): Country for arrival airport\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n        seat_class (str): Seat class (e.g., \"Economy (include Basic)\")\n        export_path (str | None): Optional path to export results (.json or .csv)\n\n    Returns:\n        dict: Flight scraping results\n    \"\"\"\n    script = f\"\"\"\nimport asyncio\nimport json\nfrom google_flights_scraper import GoogleFlightsScraper\n\nasync def main():\n    scraper = GoogleFlightsScraper()\n    result = await scraper.scrape_flight(\n        departure_code=\"{departure_code}\",\n        departure_country=\"{departure_country}\",\n        arrival_code=\"{arrival_code}\",\n        arrival_country=\"{arrival_country}\",\n        start_date=\"{start_date}\",\n        end_date=\"{end_date}\",\n        seat_class=\"{seat_class}\",\n        export_path={f'\"{export_path}\"' if export_path else \"None\"}\n    )\n    print(json.dumps(result, default=str))\n\nasyncio.run(main())\n\"\"\"\n    return _run_script(script)\n</code></pre>"},{"location":"reference/google_flights_scraper/jupyter_helper/#google_flights_scraper.jupyter_helper.scrape_multiple_destinations","title":"<code>scrape_multiple_destinations(departure_code, departure_country, arrival_codes, arrival_countries, start_date, end_date, seat_classes, output_path=None, delay_seconds=3.0, n_jobs=1)</code>","text":"<p>Scrape multiple destinations in subprocess to avoid asyncio conflicts with Jupyter.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_codes</code> <code>list[str]</code> <p>List of IATA codes or cities for arrival airports</p> required <code>arrival_countries</code> <code>list[str]</code> <p>List of countries (same length as arrival_codes)</p> required <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <code>seat_classes</code> <code>list[str]</code> <p>List of seat classes (same length as arrival_codes)</p> required <code>output_path</code> <code>str | None</code> <p>Optional path to save CSV output</p> <code>None</code> <code>delay_seconds</code> <code>float</code> <p>Delay between searches in seconds when n_jobs=1</p> <code>3.0</code> <code>n_jobs</code> <code>int</code> <p>Number of concurrent scrapes (default 1)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Results for all destinations</p> Source code in <code>src/google_flights_scraper/jupyter_helper.py</code> <pre><code>def scrape_multiple_destinations(\n    departure_code: str,\n    departure_country: str,\n    arrival_codes: list[str],\n    arrival_countries: list[str],\n    start_date: str,\n    end_date: str,\n    seat_classes: list[str],\n    output_path: str | None = None,\n    delay_seconds: float = 3.0,\n    n_jobs: int = 1,\n):\n    \"\"\"Scrape multiple destinations in subprocess to avoid asyncio conflicts with Jupyter.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_codes (list[str]): List of IATA codes or cities for arrival airports\n        arrival_countries (list[str]): List of countries (same length as arrival_codes)\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n        seat_classes (list[str]): List of seat classes (same length as arrival_codes)\n        output_path (str | None): Optional path to save CSV output\n        delay_seconds (float): Delay between searches in seconds when n_jobs=1\n        n_jobs (int): Number of concurrent scrapes (default 1)\n\n    Returns:\n        DataFrame: Results for all destinations\n    \"\"\"\n    script = f\"\"\"\nimport asyncio\nimport json\nfrom google_flights_scraper.batch_scraper import scrape_multiple_destinations\n\nasync def main():\n    arrival_codes = {arrival_codes}\n    arrival_countries = {arrival_countries}\n    seat_classes = {seat_classes}\n\n    df = await scrape_multiple_destinations(\n        departure_code=\"{departure_code}\",\n        departure_country=\"{departure_country}\",\n        arrival_codes=arrival_codes,\n        arrival_countries=arrival_countries,\n        start_date=\"{start_date}\",\n        end_date=\"{end_date}\",\n        seat_classes=seat_classes,\n        output_path={f'\"{output_path}\"' if output_path else \"None\"},\n        delay_seconds={delay_seconds},\n        n_jobs={n_jobs}\n    )\n    print(df.to_json(orient='records'))\n\nasyncio.run(main())\n\"\"\"\n    import pandas as pd\n\n    data = _run_script(script)\n    return pd.DataFrame(data)\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/","title":"parsers","text":"<p>Data extraction and parsing functions for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.create_empty_flight_info","title":"<code>create_empty_flight_info()</code>","text":"<p>Create an empty flight info dictionary structure.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Empty flight info structure with all fields set to None or empty lists</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def create_empty_flight_info():\n    \"\"\"Create an empty flight info dictionary structure.\n\n    Returns:\n        dict: Empty flight info structure with all fields set to None or empty lists\n    \"\"\"\n    return {\n        \"airline\": None,\n        \"departure_airport\": None,\n        \"departure_date\": None,\n        \"departure_time\": None,\n        \"num_stops\": None,\n        \"connection_airports\": [],\n        \"layover_durations\": [],\n        \"arrival_airport\": None,\n        \"arrival_date\": None,\n        \"arrival_time\": None,\n        \"duration_minutes\": None,\n        \"duration_str\": None,\n        \"carry_on_bags\": None,\n        \"checked_bags\": None,\n    }\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_airline","title":"<code>extract_airline(flight_description)</code>","text":"<p>Extract airline from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Airline name or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_airline(flight_description: str):\n    \"\"\"Extract airline from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        str: Airline name or None\n    \"\"\"\n    if m := re.search(r\"flight with ([^.]+)\", flight_description):\n        return m.group(1).strip()\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_arrival_info","title":"<code>extract_arrival_info(flight_description)</code>","text":"<p>Extract arrival airport, time, and date from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(airport, time, date) or (None, None, None)</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_arrival_info(flight_description: str):\n    \"\"\"Extract arrival airport, time, and date from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (airport, time, date) or (None, None, None)\n    \"\"\"\n    arr_pattern = (\n        r\"arrives at (.*?) at (\\d{1,2}:\\d{2}\\s?[AP]M) \"\n        r\"on ([A-Za-z]+, [A-Za-z]+ \\d{1,2})\"\n    )\n    if m := re.search(arr_pattern, flight_description):\n        return m.group(1).strip(), m.group(2).strip(), m.group(3).strip()\n    return None, None, None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_baggage_info","title":"<code>extract_baggage_info(flight_description)</code>","text":"<p>Extract carry-on and checked bag information from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(carry_on_bags, checked_bags) as integers or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_baggage_info(flight_description: str):\n    \"\"\"Extract carry-on and checked bag information from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (carry_on_bags, checked_bags) as integers or None\n    \"\"\"\n    carry_on_bags = None\n    checked_bags = None\n\n    if m := re.search(r\"(\\d+) carry-on bag\", flight_description):\n        carry_on_bags = int(m.group(1))\n\n    if m := re.search(r\"(\\d+) checked bags\", flight_description):\n        checked_bags = int(m.group(1))\n\n    return carry_on_bags, checked_bags\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_departure_info","title":"<code>extract_departure_info(flight_description)</code>","text":"<p>Extract departure airport, time, and date from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(airport, time, date) or (None, None, None)</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_departure_info(flight_description: str):\n    \"\"\"Extract departure airport, time, and date from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (airport, time, date) or (None, None, None)\n    \"\"\"\n    dep_pattern = (\n        r\"Leaves (.*?) at (\\d{1,2}:\\d{2}\\s?[AP]M) \"\n        r\"on ([A-Za-z]+, [A-Za-z]+ \\d{1,2})\"\n    )\n    if m := re.search(dep_pattern, flight_description):\n        return m.group(1).strip(), m.group(2).strip(), m.group(3).strip()\n    return None, None, None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_duration","title":"<code>extract_duration(flight_description)</code>","text":"<p>Extract flight duration from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(duration_minutes, duration_str) or (None, None)</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_duration(flight_description: str):\n    \"\"\"Extract flight duration from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (duration_minutes, duration_str) or (None, None)\n    \"\"\"\n    if m := re.search(r\"Total duration (\\d+) hr (\\d+) min\", flight_description):\n        hours = int(m.group(1))\n        minutes = int(m.group(2))\n        return hours * 60 + minutes, f\"{hours} hr {minutes} min\"\n\n    if m := re.search(r\"Total duration (\\d+) hr\", flight_description):\n        hours = int(m.group(1))\n        return hours * 60, f\"{hours} hr\"\n\n    if m := re.search(r\"Total duration (\\d+) min\", flight_description):\n        minutes = int(m.group(1))\n        return minutes, f\"{minutes} min\"\n\n    return None, None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_final_price","title":"<code>extract_final_price(page, timeout)</code>  <code>async</code>","text":"<p>Extract the final price from the booking page.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>timeout</code> <code>int</code> <p>Timeout for waiting operations (in milliseconds)</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Final price in US dollars, or None if not found</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>async def extract_final_price(page: Page, timeout: int):\n    \"\"\"Extract the final price from the booking page.\n\n    Args:\n        page (Page): Playwright Page instance\n        timeout (int): Timeout for waiting operations (in milliseconds)\n\n    Returns:\n        int: Final price in US dollars, or None if not found\n    \"\"\"\n    # Wait for page to fully load\n    await wait_until_stable(\n        page,\n        \"div[role='progressbar']\",\n        stable_duration=2.0,\n        timeout=timeout,\n    )\n\n    # Target the specific price element near \"Lowest total price\" text\n    selector = \"div:has-text('Lowest total price') div span[aria-label*='US dollars']\"\n\n    try:\n        price_element = page.locator(selector).first\n        await price_element.wait_for(state=\"visible\", timeout=timeout)\n        aria_label = await price_element.get_attribute(\"aria-label\")\n\n        if aria_label and (m := re.search(r\"(\\d+(?:,\\d{3})*) US dollars\", aria_label)):\n            return int(m.group(1).replace(\",\", \"\"))\n\n        return None\n\n    except PlaywrightTimeoutError:\n        print(\"Price element not found\", file=sys.stderr)\n        return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_flight_details","title":"<code>extract_flight_details(flight_element)</code>  <code>async</code>","text":"<p>Extract all flight details from a flight element.</p> <p>Parameters:</p> Name Type Description Default <code>flight_element</code> <code>Locator</code> <p>Playwright Locator containing flight info</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>flight_info dictionary</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>async def extract_flight_details(flight_element: Locator):\n    \"\"\"Extract all flight details from a flight element.\n\n    Args:\n        flight_element (Locator): Playwright Locator containing flight info\n\n    Returns:\n        dict: flight_info dictionary\n    \"\"\"\n    flight_info = create_empty_flight_info()\n\n    flight_desc_locator = flight_element.locator(\"div[aria-label^='From ']\")\n\n    try:\n        flight_description = await flight_desc_locator.get_attribute(\"aria-label\")\n    except Exception:\n        return flight_info\n\n    if flight_description is None:\n        return flight_info\n\n    # Clean the string\n    flight_description = flight_description.replace(\"\\u202f\", \" \").replace(\"\\xa0\", \" \")\n\n    # Extract all information using helper functions\n    flight_info[\"airline\"] = extract_airline(flight_description)\n\n    (\n        flight_info[\"departure_airport\"],\n        flight_info[\"departure_time\"],\n        flight_info[\"departure_date\"],\n    ) = extract_departure_info(flight_description)\n\n    flight_info[\"arrival_airport\"], flight_info[\"arrival_time\"], flight_info[\"arrival_date\"] = (\n        extract_arrival_info(flight_description)\n    )\n\n    flight_info[\"num_stops\"] = extract_num_stops(flight_description)\n\n    flight_info[\"connection_airports\"], flight_info[\"layover_durations\"] = extract_layover_info(\n        flight_description\n    )\n\n    flight_info[\"duration_minutes\"], flight_info[\"duration_str\"] = extract_duration(\n        flight_description\n    )\n\n    flight_info[\"carry_on_bags\"], flight_info[\"checked_bags\"] = extract_baggage_info(\n        flight_description\n    )\n    return flight_info\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_layover_info","title":"<code>extract_layover_info(flight_description)</code>","text":"<p>Extract connection airports and layover durations from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(connection_airports, layover_durations) as lists</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_layover_info(flight_description: str):\n    \"\"\"Extract connection airports and layover durations from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (connection_airports, layover_durations) as lists\n    \"\"\"\n    # Pattern for \"layover at [airport name]\" - handles hours only, minutes only, or both\n    pattern_at = (\n        r\"Layover \\(\\d+ of \\d+\\) is a (\\d+\\s+(?:hr|min)(?:\\s+\\d+\\s+min)?)\"\n        r\"(?: overnight)? layover at ([^.]+?)(?:\\sin\\s[^.]+)?\\.(?:\\s|$)\"\n    )\n\n    # Pattern for \"layover in [city]\" - handles hours only, minutes only, or both\n    pattern_in = (\n        r\"Layover \\(\\d+ of \\d+\\) is a (\\d+\\s+(?:hr|min)(?:\\s+\\d+\\s+min)?)\"\n        r\"(?: overnight)? layover in ([^.]+?)\\.(?:\\s+Transfer)?\"\n    )\n\n    matches_at = re.findall(pattern_at, flight_description)\n    matches_in = re.findall(pattern_in, flight_description)\n\n    all_matches = matches_at + matches_in\n    if all_matches:\n        layover_durations = [m[0].strip() for m in all_matches]\n        connection_airports = [m[1].strip() for m in all_matches]\n        return connection_airports, layover_durations\n    return [], []\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_num_stops","title":"<code>extract_num_stops(flight_description)</code>","text":"<p>Extract number of stops from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Number of stops or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_num_stops(flight_description: str):\n    \"\"\"Extract number of stops from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        int: Number of stops or None\n    \"\"\"\n    if \"Nonstop\" in flight_description:\n        return 0\n    elif m := re.search(r\"(\\d+) stop\", flight_description):\n        return int(m.group(1))\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_price_classification_text","title":"<code>extract_price_classification_text(page, timeout)</code>  <code>async</code>","text":"<p>Find and extract the price classification text from the page.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>timeout</code> <code>int</code> <p>Timeout for waiting operations (in milliseconds)</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Text containing price classification, or None if not found</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>async def extract_price_classification_text(page: Page, timeout: int):\n    \"\"\"Find and extract the price classification text from the page.\n\n    Args:\n        page (Page): Playwright Page instance\n        timeout (int): Timeout for waiting operations (in milliseconds)\n\n    Returns:\n        str: Text containing price classification, or None if not found\n    \"\"\"\n    selector = (\n        \"h3:has-text('Price insights') ~ * \"\n        \"div:has-text(' is '):has-text(' for '):has(span:text-matches('low|high|typical', 'i'))\"\n    )\n\n    try:\n        element = page.locator(selector).first\n        await element.wait_for(state=\"visible\", timeout=timeout)\n        return await element.inner_text()\n    except PlaywrightTimeoutError:\n        return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_price_relativity","title":"<code>extract_price_relativity(page, timeout)</code>  <code>async</code>","text":"<p>Extract price relativity information from final page.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>Playwright Page instance</p> required <code>timeout</code> <code>int</code> <p>Timeout for waiting operations (in milliseconds)</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(classification, amount) where classification is one of    'typical', 'high', 'low', or None; amount is integer or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>async def extract_price_relativity(page: Page, timeout: int):\n    \"\"\"Extract price relativity information from final page.\n\n    Args:\n        page (Page): Playwright Page instance\n        timeout (int): Timeout for waiting operations (in milliseconds)\n\n    Returns:\n        tuple: (classification, amount) where classification is one of\n               'typical', 'high', 'low', or None; amount is integer or None\n    \"\"\"\n    text = await extract_price_classification_text(page, timeout)\n\n    if not text:\n        return None, None\n\n    classification = parse_price_classification(text)\n    amount = parse_price_difference(text)\n\n    return classification, amount\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.parse_price_classification","title":"<code>parse_price_classification(text)</code>","text":"<p>Parse classification from price relativity text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text containing price classification</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>'low', 'high', 'typical', or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def parse_price_classification(text: str):\n    \"\"\"Parse classification from price relativity text.\n\n    Args:\n        text (str): Text containing price classification\n\n    Returns:\n        str: 'low', 'high', 'typical', or None\n    \"\"\"\n    if not text:\n        return None\n\n    text_lower = text.lower()\n\n    if \"low\" in text_lower:\n        return \"low\"\n    elif \"high\" in text_lower:\n        return \"high\"\n    elif \"typical\" in text_lower:\n        return \"typical\"\n\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.parse_price_difference","title":"<code>parse_price_difference(text)</code>","text":"<p>Parse price difference amount from price relativity text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text containing price difference</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Amount saved (for 'cheaper'), 0 (for 'high'/'typical'), or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def parse_price_difference(text: str):\n    \"\"\"Parse price difference amount from price relativity text.\n\n    Args:\n        text (str): Text containing price difference\n\n    Returns:\n        int: Amount saved (for 'cheaper'), 0 (for 'high'/'typical'), or None\n    \"\"\"\n    if not text:\n        return None\n\n    text_lower = text.lower()\n\n    if \"cheaper\" in text_lower:\n        if m := re.search(r\"\\$(\\d+(?:,\\d{3})*)\\s+cheaper\", text):\n            return int(m.group(1).replace(\",\", \"\"))\n        return 0\n    elif \"low\" in text_lower or \"high\" in text_lower or \"typical\" in text_lower:\n        return 0\n\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/scraper/","title":"scraper","text":"<p>Main scraper orchestration class.</p>"},{"location":"reference/google_flights_scraper/scraper/#google_flights_scraper.scraper.GoogleFlightsScraper","title":"<code>GoogleFlightsScraper</code>","text":"<p>Web scraper for Google Flights using Playwright.</p> Source code in <code>src/google_flights_scraper/scraper.py</code> <pre><code>class GoogleFlightsScraper:\n    \"\"\"Web scraper for Google Flights using Playwright.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the scraper with airport codes data.\"\"\"\n        package_dir = Path(__file__).parent.parent.parent\n        csv_path = package_dir / \"data\" / \"airport_codes.csv\"\n        self.airport_codes_df = pd.read_csv(csv_path)\n\n        self.wait_time = DEFAULT_TIMEOUT\n\n        # Playwright instances\n        self.playwright = None\n        self.browser = None\n        self.context = None\n        self.page = None\n\n    @property\n    def _page(self) -&gt; Page:\n        \"\"\"Get page instance, raising error if not initialized.\n\n        Raises:\n            RuntimeError: If browser not initialized.\n        \"\"\"\n        if self.page is None:\n            raise RuntimeError(\"Browser not initialized. Call scrape_flight first.\")\n        return self.page\n\n    def _create_result_structure(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n    ):\n        \"\"\"Create the initial result structure for storing flight data.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country of departure airport or city\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country of arrival airport or city\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class string\n\n        Returns:\n            dict: Empty result structure\n        \"\"\"\n        return {\n            \"inputs\": {\n                \"departure_airport\": departure_code,\n                \"departure_country\": departure_country,\n                \"arrival_airport\": arrival_code,\n                \"arrival_country\": arrival_country,\n                \"departure_date\": start_date,\n                \"return_date\": end_date,\n                \"seat_class\": seat_class,\n            },\n            \"departure_flight\": create_empty_flight_info(),\n            \"return_flight\": create_empty_flight_info(),\n            \"price\": None,\n            \"price_classification\": None,\n            \"price_difference\": None,\n            \"price_relativity\": None,\n            \"status\": None,\n            \"url\": None,\n        }\n\n    def _validate_inputs(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        seat_class: str,\n        start_date: str,\n        end_date: str,\n        export_path: str | None,\n    ):\n        \"\"\"Validate all input parameters.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country for departure airport\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country for arrival airport\n            seat_class (str): Seat class string\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            export_path (str | None): Path to export file\n\n        Returns:\n            bool: True if flight is domestic US\n        \"\"\"\n        for code in [departure_code, arrival_code]:\n            validate_airport_code(code, self.airport_codes_df)\n\n        is_domestic_us = is_domestic_us_flight(\n            departure_country,\n            arrival_country,\n            self.airport_codes_df,\n        )\n\n        validate_seat_class(seat_class, is_domestic_us)\n        validate_dates(start_date, end_date)\n        validate_export_params(export_path)\n\n        return is_domestic_us\n\n    async def _fill_search_form(\n        self,\n        departure_code: str,\n        arrival_code: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n        is_domestic_us: bool,\n    ):\n        \"\"\"Fill out the Google Flights search form.\n\n        Args:\n            departure_code (str): IATA code for departure airport\n            arrival_code (str): IATA code for arrival airport\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class string\n            is_domestic_us (bool): Whether flight is domestic US\n        \"\"\"\n        await enter_airports(self._page, departure_code, arrival_code)\n        await enter_dates(self._page, start_date, end_date)\n        await select_seat_class(self._page, seat_class, is_domestic_us)\n        await press_search_button(self._page)\n\n    async def _find_flight_with_retry(\n        self,\n        result: dict,\n        key: str,\n        max_retries: int = 3,\n        sleep_s: float = 0.5,\n    ):\n        \"\"\"Find best flight element with retry and extract details.\n\n        Args:\n            result (dict): Dictionary to populate with flight details\n            key (str): Dict key to add data to (departure_flight or return_flight)\n            max_retries (int): Number of times to retry selecting element\n            sleep_s (float): How long to sleep (seconds) in between each try\n\n        Returns:\n            str | None: Error message if failed, None if successful\n        \"\"\"\n        for attempt in range(max_retries):\n            try:\n                flight = await find_and_select_best_flight(self._page, timeout=self.wait_time)\n\n                if flight is None:\n                    return f\"No {key.replace('_', ' ')} found.\"\n\n                result[key] = await extract_flight_details(flight)\n\n                await flight.click()\n                return None\n\n            except Exception as e:\n                if attempt == max_retries - 1:\n                    return f\"Error finding {key}: {str(e)}\"\n                await asyncio.sleep(sleep_s)\n\n        return f\"Failed to find {key} after {max_retries} retries.\"\n\n    async def _select_best_flights(self, result: dict):\n        \"\"\"Select the best departure and return flights and extract details.\n\n        Args:\n            result (dict): Dictionary to populate with flight details\n\n        Returns:\n            tuple: (updated result dictionary, success status message)\n        \"\"\"\n        err = await self._find_flight_with_retry(result, key=\"departure_flight\")\n        if err:\n            return result, err\n\n        err = await self._find_flight_with_retry(result, key=\"return_flight\")\n        if err:\n            return result, err\n\n        await asyncio.sleep(1)\n\n        result[\"price\"] = await extract_final_price(self._page, timeout=self.wait_time * 2)\n\n        if result[\"price\"] is None:\n            return result, \"Error: Price not found\"\n\n        result[\"url\"] = self._page.url\n\n        return result, \"Ran successfully.\"\n\n    def _calc_price_rel(self, price: int, price_difference: int | None):\n        \"\"\"Calculate price relativity (% discount).\n\n        Args:\n            price (int): Final flight price\n            price_difference (int | None): How much cheaper flight is than usual\n\n        Returns:\n            float | None: Percentage discount or None\n        \"\"\"\n        if price_difference is not None and price is not None:\n            return round(float(price_difference / (price + price_difference)), 4)\n        return None\n\n    def _export_data(self, result: dict, export_path: str):\n        \"\"\"Export dict to file based on extension.\n\n        Args:\n            result (dict): Resulting dictionary after scraping\n            export_path (str): Path to export file to\n        \"\"\"\n        if export_path.endswith(\".json\"):\n            with open(export_path, \"w\") as f:\n                f.write(json.dumps(result, indent=2))\n        elif export_path.endswith(\".csv\"):\n            df = pd.json_normalize(result, sep=\"_\")\n            df.to_csv(export_path, index=False)\n\n    async def scrape_flight(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n        export_path: str | None = None,\n    ):\n        \"\"\"Scrape Google Flights for specified route and parameters.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country for departure airport\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country for arrival airport\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)\n            export_path (str | None): Path to export file (.json or .csv)\n\n        Returns:\n            dict: Complete flight information as dictionary\n        \"\"\"\n        result = self._create_result_structure(\n            departure_code,\n            departure_country,\n            arrival_code,\n            arrival_country,\n            start_date,\n            end_date,\n            seat_class,\n        )\n\n        try:\n            is_domestic_us = self._validate_inputs(\n                departure_code,\n                departure_country,\n                arrival_code,\n                arrival_country,\n                seat_class,\n                start_date,\n                end_date,\n                export_path,\n            )\n\n            self.playwright, self.browser, self.context, self.page = await setup_browser()\n\n            await self.page.goto(\"https://www.google.com/travel/flights\")\n\n            await self._fill_search_form(\n                departure_code,\n                arrival_code,\n                start_date,\n                end_date,\n                seat_class,\n                is_domestic_us,\n            )\n\n            result, status = await self._select_best_flights(result)\n\n            if status == \"Ran successfully.\":\n                (\n                    result[\"price_classification\"],\n                    result[\"price_difference\"],\n                ) = await extract_price_relativity(self.page, timeout=2000)\n\n            result[\"price_relativity\"] = self._calc_price_rel(\n                result[\"price\"], result[\"price_difference\"]\n            )\n\n        except Exception as e:\n            print(f\"Error scraping flight: {e}\", file=sys.stderr)\n            status = f\"Error: {str(e)}\"\n        finally:\n            if self.page:\n                await self.page.close()\n            if self.context:\n                await self.context.close()\n            if self.browser:\n                await self.browser.close()\n            if self.playwright:\n                await self.playwright.stop()\n\n        result[\"status\"] = status\n\n        if export_path:\n            self._export_data(result, export_path)\n\n        return result\n</code></pre>"},{"location":"reference/google_flights_scraper/scraper/#google_flights_scraper.scraper.GoogleFlightsScraper.scrape_flight","title":"<code>scrape_flight(departure_code, departure_country, arrival_code, arrival_country, start_date, end_date, seat_class, export_path=None)</code>  <code>async</code>","text":"<p>Scrape Google Flights for specified route and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_code</code> <code>str</code> <p>IATA code or city for arrival airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <code>seat_class</code> <code>str</code> <p>Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)</p> required <code>export_path</code> <code>str | None</code> <p>Path to export file (.json or .csv)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Complete flight information as dictionary</p> Source code in <code>src/google_flights_scraper/scraper.py</code> <pre><code>async def scrape_flight(\n    self,\n    departure_code: str,\n    departure_country: str,\n    arrival_code: str,\n    arrival_country: str,\n    start_date: str,\n    end_date: str,\n    seat_class: str,\n    export_path: str | None = None,\n):\n    \"\"\"Scrape Google Flights for specified route and parameters.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_code (str): IATA code or city for arrival airport\n        arrival_country (str): Country for arrival airport\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n        seat_class (str): Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)\n        export_path (str | None): Path to export file (.json or .csv)\n\n    Returns:\n        dict: Complete flight information as dictionary\n    \"\"\"\n    result = self._create_result_structure(\n        departure_code,\n        departure_country,\n        arrival_code,\n        arrival_country,\n        start_date,\n        end_date,\n        seat_class,\n    )\n\n    try:\n        is_domestic_us = self._validate_inputs(\n            departure_code,\n            departure_country,\n            arrival_code,\n            arrival_country,\n            seat_class,\n            start_date,\n            end_date,\n            export_path,\n        )\n\n        self.playwright, self.browser, self.context, self.page = await setup_browser()\n\n        await self.page.goto(\"https://www.google.com/travel/flights\")\n\n        await self._fill_search_form(\n            departure_code,\n            arrival_code,\n            start_date,\n            end_date,\n            seat_class,\n            is_domestic_us,\n        )\n\n        result, status = await self._select_best_flights(result)\n\n        if status == \"Ran successfully.\":\n            (\n                result[\"price_classification\"],\n                result[\"price_difference\"],\n            ) = await extract_price_relativity(self.page, timeout=2000)\n\n        result[\"price_relativity\"] = self._calc_price_rel(\n            result[\"price\"], result[\"price_difference\"]\n        )\n\n    except Exception as e:\n        print(f\"Error scraping flight: {e}\", file=sys.stderr)\n        status = f\"Error: {str(e)}\"\n    finally:\n        if self.page:\n            await self.page.close()\n        if self.context:\n            await self.context.close()\n        if self.browser:\n            await self.browser.close()\n        if self.playwright:\n            await self.playwright.stop()\n\n    result[\"status\"] = status\n\n    if export_path:\n        self._export_data(result, export_path)\n\n    return result\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/","title":"validators","text":"<p>Validation functions for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.is_domestic_us_flight","title":"<code>is_domestic_us_flight(departure_country, arrival_country, airport_codes_df)</code>","text":"<p>Determine if flight is domestic US based on airport codes and cities.</p> <p>Parameters:</p> Name Type Description Default <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>airport_codes_df</code> <code>DataFrame</code> <p>DataFrame containing airport codes</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if both airports are in United States of America</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def is_domestic_us_flight(\n    departure_country: str, arrival_country: str, airport_codes_df: DataFrame\n):\n    \"\"\"Determine if flight is domestic US based on airport codes and cities.\n\n    Args:\n        departure_country (str): Country for departure airport\n        arrival_country (str): Country for arrival airport\n        airport_codes_df (DataFrame): DataFrame containing airport codes\n\n    Returns:\n        bool: True if both airports are in United States of America\n    \"\"\"\n    usa = \"United States of America\"\n    if (departure_country.upper() == usa.upper()) and (arrival_country.upper() == usa.upper()):\n        return True\n    return False\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.validate_airport_code","title":"<code>validate_airport_code(airport_code, airport_codes_df)</code>","text":"<p>Validate if airport code or city exists in dataset.</p> <p>Parameters:</p> Name Type Description Default <code>airport_code</code> <code>str</code> <p>IATA code or City to validate</p> required <code>airport_codes_df</code> <code>DataFrame</code> <p>DataFrame containing airport codes and cities</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If airport code or city is not found in dataset</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def validate_airport_code(airport_code: str, airport_codes_df: DataFrame):\n    \"\"\"Validate if airport code or city exists in dataset.\n\n    Args:\n        airport_code (str): IATA code or City to validate\n        airport_codes_df (DataFrame): DataFrame containing airport codes and cities\n\n    Raises:\n        ValueError: If airport code or city is not found in dataset\n    \"\"\"\n    # IATA Code\n    if not airport_codes_df[\"IATA\"].str.upper().isin([airport_code.upper()]).any():\n        # Cities\n        if not airport_codes_df[\"City\"].str.upper().isin([airport_code.upper()]).any():\n            raise ValueError(f\"Invalid airport input: {airport_code}\")\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.validate_dates","title":"<code>validate_dates(start_date, end_date)</code>","text":"<p>Validate that end_date is after start_date.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If dates are invalid or end_date is before start_date</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def validate_dates(start_date: str, end_date: str):\n    \"\"\"Validate that end_date is after start_date.\n\n    Args:\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n\n    Raises:\n        ValueError: If dates are invalid or end_date is before start_date\n    \"\"\"\n    try:\n        start = datetime.strptime(start_date, \"%m/%d/%Y\")\n        end = datetime.strptime(end_date, \"%m/%d/%Y\")\n    except ValueError as e:\n        raise ValueError(\"Invalid date format. Expected MM/DD/YYYY:\") from e\n\n    if end &lt;= start:\n        raise ValueError(f\"Return date ({end_date}) must be after departure date ({start_date})\")\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.validate_export_params","title":"<code>validate_export_params(export_path=None)</code>","text":"<p>Validate export parameters.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>str | None</code> <p>Path to export file</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If export_path has invalid extension</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def validate_export_params(export_path: str | None = None):\n    \"\"\"Validate export parameters.\n\n    Args:\n        export_path (str | None): Path to export file\n\n    Raises:\n        ValueError: If export_path has invalid extension\n    \"\"\"\n    if export_path:\n        # Check file extension\n        if not (export_path.endswith(\".json\") or export_path.endswith(\".csv\")):\n            raise ValueError(f\"Export path must end with .json or .csv, got: {export_path}\")\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.validate_seat_class","title":"<code>validate_seat_class(seat_class, is_domestic_us)</code>","text":"<p>Validate seat class selection based on flight type.</p> <p>Parameters:</p> Name Type Description Default <code>seat_class</code> <code>str</code> <p>Seat class string</p> required <code>is_domestic_us</code> <code>bool</code> <p>Whether flight is domestic US</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If seat class is invalid for the flight type</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def validate_seat_class(seat_class: str, is_domestic_us: bool):\n    \"\"\"Validate seat class selection based on flight type.\n\n    Args:\n        seat_class (str): Seat class string\n        is_domestic_us (bool): Whether flight is domestic US\n\n    Raises:\n        ValueError: If seat class is invalid for the flight type\n    \"\"\"\n    # Validate based on flight type\n    if is_domestic_us:\n        if seat_class.lower() not in VALID_CLASSES_DOMESTIC_US:\n            raise ValueError(f\"Invalid seat class for domestic US flight: {seat_class}\")\n    else:\n        if seat_class.lower() not in VALID_CLASSES_INTERNATIONAL:\n            raise ValueError(f\"Invalid seat class for international flight: {seat_class}\")\n</code></pre>"},{"location":"tutorial/batch_request/","title":"Tutorial: Batch Flight Requests","text":"In\u00a0[1]: Copied! <pre># Import\nfrom datetime import datetime, timedelta\n\nfrom google_flights_scraper.jupyter_helper import (\n    scrape_date_range,\n    scrape_multiple_destinations,\n)\n\n# Get today's date\ntoday = datetime.today()\n</pre> # Import from datetime import datetime, timedelta  from google_flights_scraper.jupyter_helper import (     scrape_date_range,     scrape_multiple_destinations, )  # Get today's date today = datetime.today() <p>Below are the possible parameters when making a request:</p> <p>Required Inputs</p> <p><code>departure_code</code> : Departure airport or city (a single location) <code>departure_country</code> Departure country (a single country) <code>arrival_codes</code> : A list of possible destination airports or cities <code>arrival_countries</code> : The matching list of possible destination countries <code>start_date</code> : Departure date (in <code>\"MM/DD/YYY\"</code> format) <code>end_date</code> : Arrrival date  (in <code>\"MM/DD/YYY\"</code> format) <code>seat_classes</code> : The matching list of seat classes (reason this is <code>list</code> and not <code>str</code> is because domestic and international flights can have different class names)</p> <p>Optional Inputs</p> <p><code>output_path</code> : path to output <code>.csv</code>  (ex: <code>export.csv</code>) <code>delay_seconds</code>: How many seconds to delay between requests. Can be helpful to increase if you are being rate limited by Google. <code>n_jobs</code>: Number of concurrent scrapes (default 1). When &gt;1, <code>delay_seconds</code> is ignored and concurrency is controlled by the semaphore.</p> In\u00a0[2]: Copied! <pre># Search Mapping\ncity_search = {\n    \"SEA\": {\"country\": \"United States of America\", \"seat_class\": \"Economy (exclude Basic)\"},\n    \"London\": {\"country\": \"United Kingdom\", \"seat_class\": \"Economy\"},\n    \"Paris\": {\"country\": \"France\", \"seat_class\": \"Economy\"},\n    \"SFO\": {\"country\": \"United States of America\", \"seat_class\": \"Economy (exclude Basic)\"},\n}\n\n# Individual Lists\ndestination_codes = list(city_search.keys())\ndestination_countries = [city_search[code][\"country\"] for code in destination_codes]\nseat_classes = [city_search[code][\"seat_class\"] for code in destination_codes]\n\n# Create Dates\nstart = (today + timedelta(weeks=8)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=10)).strftime(\"%m/%d/%Y\")\n\n# Run\ndf_destinations = scrape_multiple_destinations(\n    departure_code=\"New York\",\n    departure_country=\"United States of America\",\n    arrival_codes=destination_codes,\n    arrival_countries=destination_countries,\n    start_date=start,\n    end_date=end,\n    seat_classes=seat_classes,\n    delay_seconds=3.0,\n    n_jobs=4,\n)\n</pre> # Search Mapping city_search = {     \"SEA\": {\"country\": \"United States of America\", \"seat_class\": \"Economy (exclude Basic)\"},     \"London\": {\"country\": \"United Kingdom\", \"seat_class\": \"Economy\"},     \"Paris\": {\"country\": \"France\", \"seat_class\": \"Economy\"},     \"SFO\": {\"country\": \"United States of America\", \"seat_class\": \"Economy (exclude Basic)\"}, }  # Individual Lists destination_codes = list(city_search.keys()) destination_countries = [city_search[code][\"country\"] for code in destination_codes] seat_classes = [city_search[code][\"seat_class\"] for code in destination_codes]  # Create Dates start = (today + timedelta(weeks=8)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=10)).strftime(\"%m/%d/%Y\")  # Run df_destinations = scrape_multiple_destinations(     departure_code=\"New York\",     departure_country=\"United States of America\",     arrival_codes=destination_codes,     arrival_countries=destination_countries,     start_date=start,     end_date=end,     seat_classes=seat_classes,     delay_seconds=3.0,     n_jobs=4, ) In\u00a0[3]: Copied! <pre>df_destinations\n</pre> df_destinations Out[3]: departure_airport departure_country arrival_airport arrival_country departure_date return_date seat_class departure_airline departure_departure_airport departure_departure_date ... return_duration_minutes return_duration_str return_carry_on_bags return_checked_bags price price_classification price_difference price_relativity status url 0 New York United States of America Paris France 04/07/2026 04/21/2026 Economy American John F. Kennedy International Airport Tuesday, April 7 ... 730 12 hr 10 min NaN NaN 436 low 435 0.4994 Ran successfully. https://www.google.com/travel/flights/booking?... 1 New York United States of America SFO United States of America 04/07/2026 04/21/2026 Economy (exclude Basic) United Newark Liberty International Airport Tuesday, April 7 ... 337 5 hr 37 min 1.0 0.0 329 low 307 0.4827 Ran successfully. https://www.google.com/travel/flights/booking?... 2 New York United States of America SEA United States of America 04/07/2026 04/21/2026 Economy (exclude Basic) United Newark Liberty International Airport Tuesday, April 7 ... 321 5 hr 21 min 1.0 0.0 329 typical 0 0.0000 Ran successfully. https://www.google.com/travel/flights/booking?... 3 New York United States of America London United Kingdom 04/07/2026 04/21/2026 Economy Norse Atlantic UK John F. Kennedy International Airport Tuesday, April 7 ... 470 7 hr 50 min NaN NaN 521 typical 0 0.0000 Ran successfully. https://www.google.com/travel/flights/booking?... <p>4 rows \u00d7 41 columns</p> <p>This returns a pandas DataFrame of the best flight for each destination, sorted in order of <code>price_relativity</code> highlight the flights which are the \"best deal\".</p> <p>This also contains all the other information returned by the basic flight request function.</p> <p>Here are the possible parameters for this request:</p> <p>Required Inputs</p> <p><code>departure_code</code> : Departure airport or city (a single location) <code>departure_country</code> : Departure country (a single country) <code>arrival_code</code> : Arrival airport or city (a single location) <code>arrival_country</code> : Arrival country (a single country) <code>start_date_range</code> : Start date for search (in <code>\"MM/DD/YYY\"</code> format) <code>end_date_range</code> : End date for search (in <code>\"MM/DD/YYY\"</code> format) <code>min_trip_length</code> : Minimum trip length (in days) <code>max_trip_length</code> : Maximum trip length (in days) <code>seat_class</code> : Class of seat (a single selection)</p> <p>Optional Inputs</p> <p><code>output_path</code> : path to output <code>.csv</code>  (ex: <code>export.csv</code>) <code>delay_seconds</code>: How many seconds to delay between requests. Can be helpful to increase if you are being rate limited by Google. <code>n_jobs</code>: Number of concurrent scrapes (default 1). When &gt;1, <code>delay_seconds</code> is ignored and concurrency is controlled by the semaphore.</p> In\u00a0[4]: Copied! <pre># Create Dates\nstart = (today + timedelta(weeks=11)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=12)).strftime(\"%m/%d/%Y\")\n\n# Run\ndf_dates = scrape_date_range(\n    departure_code=\"JFK\",\n    departure_country=\"United States of America\",\n    arrival_code=\"London\",\n    arrival_country=\"United Kingdom\",\n    start_date_range=start,\n    end_date_range=end,\n    min_trip_length=5,\n    max_trip_length=7,\n    seat_class=\"Economy\",\n    delay_seconds=3.0,\n    n_jobs=6,\n)\n</pre> # Create Dates start = (today + timedelta(weeks=11)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=12)).strftime(\"%m/%d/%Y\")  # Run df_dates = scrape_date_range(     departure_code=\"JFK\",     departure_country=\"United States of America\",     arrival_code=\"London\",     arrival_country=\"United Kingdom\",     start_date_range=start,     end_date_range=end,     min_trip_length=5,     max_trip_length=7,     seat_class=\"Economy\",     delay_seconds=3.0,     n_jobs=6, ) In\u00a0[5]: Copied! <pre>df_dates\n</pre> df_dates Out[5]: departure_airport departure_country arrival_airport arrival_country departure_date return_date seat_class departure_airline departure_departure_airport departure_departure_date ... return_duration_str return_carry_on_bags return_checked_bags price price_classification price_difference price_relativity status url trip_length_days 0 JFK United States of America London United Kingdom 04/30/2026 05/05/2026 Economy British Airways John F. Kennedy International Airport Thursday, April 30 ... 7 hr 55 min None None 539 low 200 0.2706 Ran successfully. https://www.google.com/travel/flights/booking?... 5 1 JFK United States of America London United Kingdom 04/29/2026 05/04/2026 Economy American John F. Kennedy International Airport Wednesday, April 29 ... 7 hr 55 min None None 543 low 196 0.2652 Ran successfully. https://www.google.com/travel/flights/booking?... 5 2 JFK United States of America London United Kingdom 04/28/2026 05/03/2026 Economy British Airways John F. Kennedy International Airport Tuesday, April 28 ... 8 hr None None 543 low 150 0.2165 Ran successfully. https://www.google.com/travel/flights/booking?... 5 3 JFK United States of America London United Kingdom 04/28/2026 05/05/2026 Economy British Airways John F. Kennedy International Airport Tuesday, April 28 ... 7 hr 55 min None None 539 low 109 0.1682 Ran successfully. https://www.google.com/travel/flights/booking?... 7 4 JFK United States of America London United Kingdom 04/28/2026 05/04/2026 Economy British Airways John F. Kennedy International Airport Tuesday, April 28 ... 7 hr 50 min None None 542 low 66 0.1086 Ran successfully. https://www.google.com/travel/flights/booking?... 6 5 JFK United States of America London United Kingdom 04/29/2026 05/05/2026 Economy American John F. Kennedy International Airport Wednesday, April 29 ... 7 hr 50 min None None 542 low 66 0.1086 Ran successfully. https://www.google.com/travel/flights/booking?... 6 <p>6 rows \u00d7 42 columns</p> <p>This also returns a pandas DataFrame of the best flight for each destination, sorted in order of <code>price_relativity</code> highlight the flights which are the \"best deal\".</p> <p>This also contains all the other information returned by the basic flight request function.</p>"},{"location":"tutorial/batch_request/#tutorial-batch-flight-requests","title":"Tutorial: Batch Flight Requests\u00b6","text":"<p>The <code>google_flights_scraper</code> package can also be used to make batch request of multiple flights where a certain criteria is varied (e.g. destination or dates)</p>"},{"location":"tutorial/batch_request/#set-up","title":"Set Up\u00b6","text":""},{"location":"tutorial/batch_request/#destination-search","title":"Destination Search\u00b6","text":"<p>Search multiple destinations on certain dates. Helpful if you know when you want to travel, but don't know where and are looking for good deals.</p>"},{"location":"tutorial/batch_request/#example-departing-from-new-york","title":"Example: Departing from New York\u00b6","text":"<p>In this example, we are departing from New York and searching for flights to SEA, London, Paris, and SFO.</p>"},{"location":"tutorial/batch_request/#date-range-search","title":"Date Range Search\u00b6","text":"<p>Search all date combinations for a specific route between certain dates. Helpful if you're flexible on timing and looking for finding cheaper days to fly.</p>"},{"location":"tutorial/batch_request/#example-jfk-to-london","title":"Example: JFK to London\u00b6","text":"<p>In this example, we are departing from JFK and arriving in London anytime within a two-week period, searching from trip from 5-7 days long.</p>"},{"location":"tutorial/simple_request/","title":"Tutorial: Simple Flight Request","text":"In\u00a0[1]: Copied! <pre># Auto-reload modules\n%load_ext autoreload\n%autoreload 2\n</pre> # Auto-reload modules %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># Import\nfrom datetime import datetime, timedelta\n\nfrom google_flights_scraper.jupyter_helper import scrape_flight\n\n# Get today's date\ntoday = datetime.today()\n</pre> # Import from datetime import datetime, timedelta  from google_flights_scraper.jupyter_helper import scrape_flight  # Get today's date today = datetime.today() <p>Below are the possible parameters when making a request:</p> <p>Required Inputs</p> <p><code>departure_code</code> : Departure airport, can be airport code or city name <code>departure_country</code> : Departure country, see <code>data/airport_codes.csv</code> for naming <code>arrival_code</code> : Arrival airport, can be airport code or city name <code>arrival_country</code> : Departure country, see <code>data/airport_codes.csv</code> for naming <code>start_date</code> : Departure date, in <code>\"MM/DD/YYYY\"</code> format <code>end_date</code> : Return date, in <code>\"MM/DD/YYYY\"</code> format <code>seat_class</code> : Class of seat to search for. Options are:</p> <ul> <li>Domestic (US):<ul> <li>Economy (include Basic)</li> <li>Economy (exclude Basic)</li> <li>Premium economy</li> <li>Business</li> <li>First</li> </ul> </li> <li>International:<ul> <li>Economy</li> <li>Premium economy</li> <li>Business</li> <li>First</li> </ul> </li> </ul> <p>Optional Inputs</p> <p><code>export_path</code> : Path and file type export to (ex: <code>export.json</code> or <code>export.csv</code>)</p> <p>This will return the following info as a <code>dict</code>:</p> <pre>{\n\"inputs\": {\n    \"departure_airport\",\n    \"departure_country\"\n    \"arrival_airport\",\n    \"arrival_country\",\n    \"departure_date\",\n    \"return_date\",\n    \"seat_class\"\n},\n\"departure_flight\": {\n    \"airline\",\n    \"departure_airport\",\n    \"departure_date\",\n    \"departure_time\",\n    \"num_stops\",\n    \"connection_airports\",\n    \"layover_durations\",\n    \"arrival_airport\",\n    \"arrival_date\",\n    \"arrival_time\"\n    \"duration_minutes\", # Total duration of travel (in minutes)\n    \"duration_str\", # Duration formatted as readability (X hr X min)\n    \"carry_on_bags\", # Sometimes None, this information doesn't always populate in Google Flights\n    \"checked_bags\" # Sometimes None, this information doesn't always populate in Google Flights\n},\n\"return_flight\": {\n    \"airline\",\n    \"departure_airport\",\n    \"departure_date\",\n    \"departure_time\",\n    \"num_stops\",\n    \"connection_airports\",\n    \"layover_durations\",\n    \"arrival_airport\",\n    \"arrival_date\",\n    \"arrival_time\"\n    \"duration_minutes\", # Total duration of travel (in minutes)\n    \"duration_str\", # Duration formatted as readability (X hr X min)\n    \"carry_on_bags\", # Sometimes None, this information doesn't always populate in Google Flights\n    \"checked_bags\" # Sometimes None, this information doesn't always populate in Google Flights\n},\n\"price\",\n\"price_classification\", # One of low, typical, or high. Sometimes null if Google Flights does not provide this info for a specific flight.\n\"price_difference\", # If price_classificaiton is low, how much cheaper this flight is than usual ($).\n\"price_relativity\": # If price_classificaiton is low, how much cheaper this flight is than usual (% off).\n\"status\" # If the scraper ran successfully, or if not, what the error was.\n\"url\" # URL of final page\n}\n</pre> In\u00a0[3]: Copied! <pre># Create Dates\nstart = (today + timedelta(weeks=4)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=5)).strftime(\"%m/%d/%Y\")\n\n# Run\nresult = scrape_flight(\n    departure_code=\"LAX\",\n    departure_country=\"United States of America\",\n    arrival_code=\"New York\",\n    arrival_country=\"United States of America\",\n    start_date=start,\n    end_date=end,\n    seat_class=\"Economy (include Basic)\",\n)\n</pre> # Create Dates start = (today + timedelta(weeks=4)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=5)).strftime(\"%m/%d/%Y\")  # Run result = scrape_flight(     departure_code=\"LAX\",     departure_country=\"United States of America\",     arrival_code=\"New York\",     arrival_country=\"United States of America\",     start_date=start,     end_date=end,     seat_class=\"Economy (include Basic)\", ) In\u00a0[4]: Copied! <pre>result\n</pre> result Out[4]: <pre>{'inputs': {'departure_airport': 'LAX',\n  'departure_country': 'United States of America',\n  'arrival_airport': 'New York',\n  'arrival_country': 'United States of America',\n  'departure_date': '03/10/2026',\n  'return_date': '03/17/2026',\n  'seat_class': 'Economy (include Basic)'},\n 'departure_flight': {'airline': 'Spirit',\n  'departure_airport': 'Los Angeles International Airport',\n  'departure_date': 'Tuesday, March 10',\n  'departure_time': '8:20 AM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'Newark Liberty International Airport',\n  'arrival_date': 'Tuesday, March 10',\n  'arrival_time': '4:35 PM',\n  'duration_minutes': 315,\n  'duration_str': '5 hr 15 min',\n  'carry_on_bags': 0,\n  'checked_bags': 0},\n 'return_flight': {'airline': 'Spirit',\n  'departure_airport': 'Newark Liberty International Airport',\n  'departure_date': 'Tuesday, March 17',\n  'departure_time': '6:59 PM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'Los Angeles International Airport',\n  'arrival_date': 'Tuesday, March 17',\n  'arrival_time': '10:14 PM',\n  'duration_minutes': 375,\n  'duration_str': '6 hr 15 min',\n  'carry_on_bags': 0,\n  'checked_bags': 0},\n 'price': 116,\n 'price_classification': 'low',\n 'price_difference': 90,\n 'price_relativity': 0.4369,\n 'status': 'Ran successfully.',\n 'url': 'https://www.google.com/travel/flights/booking?tfs=CBwQAhpGEgoyMDI2LTAzLTEwIiAKA0xBWBIKMjAyNi0wMy0xMBoDRVdSKgJOSzIEMTY5M2oHCAESA0xBWHINCAMSCS9tLzAyXzI4NhpGEgoyMDI2LTAzLTE3IiAKA0VXUhIKMjAyNi0wMy0xNxoDTEFYKgJOSzIEMTY3MGoNCAMSCS9tLzAyXzI4NnIHCAESA0xBWEABSAFwAYIBCwj___________8BmAEB&amp;tfu=CmxDalJJVUdGT1dVNTRjVmR6TFd0QlEyaGxaV2RDUnkwdExTMHRMUzEyZDJzeE1DMXVNVUZCUVVGQlIyMU1Tamt3UTFOaldVTkJFZ1pPU3pFMk56QWFDZ2lzV2hBQ0dnTlZVMFE0SEhDc1dnPT0SAggAIgYKATESATA'}</pre> <p>This returns a Nonstop flight on Spirit landing at Newark Liberty International Airport. Google Flights tends to prioritize the cheapest flight as the \"best\" flight, but sometimes will choose more expensive flights if they offer significantly better travel (usually less layover time).</p> <p>This price is classified as <code>\"low\"</code> and <code>\"price_difference\"</code> of $90 is returned (<code>\"price_relativity\"</code> = 43.69% discount).</p> In\u00a0[5]: Copied! <pre># Create Dates\nstart = (today + timedelta(weeks=8)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=10)).strftime(\"%m/%d/%Y\")\n\n# Run\nresult = scrape_flight(\n    departure_code=\"New York\",\n    departure_country=\"United States of America\",\n    arrival_code=\"Tokyo\",\n    arrival_country=\"Japan\",\n    start_date=start,\n    end_date=end,\n    seat_class=\"Premium economy\",\n)\n</pre> # Create Dates start = (today + timedelta(weeks=8)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=10)).strftime(\"%m/%d/%Y\")  # Run result = scrape_flight(     departure_code=\"New York\",     departure_country=\"United States of America\",     arrival_code=\"Tokyo\",     arrival_country=\"Japan\",     start_date=start,     end_date=end,     seat_class=\"Premium economy\", ) In\u00a0[6]: Copied! <pre>result\n</pre> result Out[6]: <pre>{'inputs': {'departure_airport': 'New York',\n  'departure_country': 'United States of America',\n  'arrival_airport': 'Tokyo',\n  'arrival_country': 'Japan',\n  'departure_date': '04/07/2026',\n  'return_date': '04/21/2026',\n  'seat_class': 'Premium economy'},\n 'departure_flight': {'airline': 'United',\n  'departure_airport': 'Newark Liberty International Airport',\n  'departure_date': 'Tuesday, April 7',\n  'departure_time': '7:52 AM',\n  'num_stops': 1,\n  'connection_airports': ['Denver International Airport'],\n  'layover_durations': ['1 hr 11 min'],\n  'arrival_airport': 'Narita International Airport',\n  'arrival_date': 'Wednesday, April 8',\n  'arrival_time': '2:45 PM',\n  'duration_minutes': 1073,\n  'duration_str': '17 hr 53 min',\n  'carry_on_bags': None,\n  'checked_bags': None},\n 'return_flight': {'airline': 'United',\n  'departure_airport': 'Narita International Airport',\n  'departure_date': 'Tuesday, April 21',\n  'departure_time': '5:25 PM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'Newark Liberty International Airport',\n  'arrival_date': 'Tuesday, April 21',\n  'arrival_time': '5:10 PM',\n  'duration_minutes': 765,\n  'duration_str': '12 hr 45 min',\n  'carry_on_bags': None,\n  'checked_bags': None},\n 'price': 2170,\n 'price_classification': None,\n 'price_difference': None,\n 'price_relativity': None,\n 'status': 'Ran successfully.',\n 'url': 'https://www.google.com/travel/flights/booking?tfs=CBwQAhpsEgoyMDI2LTA0LTA3IiAKA0VXUhIKMjAyNi0wNC0wNxoDREVOKgJVQTIEMjMzNiIfCgNERU4SCjIwMjYtMDQtMDcaA05SVCoCVUEyAzE0M2oNCAMSCS9tLzAyXzI4NnIMCAMSCC9tLzA3ZGZrGkkSCjIwMjYtMDQtMjEiHgoDTlJUEgoyMDI2LTA0LTIxGgNFV1IqAlVBMgI3OGoMCAMSCC9tLzA3ZGZrcg0IAxIJL20vMDJfMjg2QAFIAnABggELCP___________wGYAQE&amp;tfu=CmxDalJJVUdGT1dVNTRjVmR6TFd0QlEyaG9hbWRDUnkwdExTMHRMUzEyZDJzeE1DMXVNVUZCUVVGQlIyMU1TaTA0UVZGSVVVRkJFZ1JWUVRjNEdnc0kwWjRORUFJYUExVlRSRGdjY05HZURRPT0SAggAIgMKATE'}</pre> <p>This returns a flight on United with one layover. You can see the layover details (airport, duration) are included.</p> <p>The <code>'price_classification'</code> and <code>'price_difference'</code> here are <code>None</code>. I've found that Google Flights offers these suggestions less for non-Economy flights.</p> In\u00a0[7]: Copied! <pre># Create Dates\nstart = (today + timedelta(weeks=6)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=7)).strftime(\"%m/%d/%Y\")\n\n# Run\nresult = scrape_flight(\n    departure_code=\"SFO\",\n    departure_country=\"United States of America\",\n    arrival_code=\"DCA\",\n    arrival_country=\"United States of America\",\n    start_date=start,\n    end_date=end,\n    seat_class=\"Economy (exclude Basic)\",\n)\n</pre> # Create Dates start = (today + timedelta(weeks=6)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=7)).strftime(\"%m/%d/%Y\")  # Run result = scrape_flight(     departure_code=\"SFO\",     departure_country=\"United States of America\",     arrival_code=\"DCA\",     arrival_country=\"United States of America\",     start_date=start,     end_date=end,     seat_class=\"Economy (exclude Basic)\", ) In\u00a0[8]: Copied! <pre>result\n</pre> result Out[8]: <pre>{'inputs': {'departure_airport': 'SFO',\n  'departure_country': 'United States of America',\n  'arrival_airport': 'DCA',\n  'arrival_country': 'United States of America',\n  'departure_date': '03/24/2026',\n  'return_date': '03/31/2026',\n  'seat_class': 'Economy (exclude Basic)'},\n 'departure_flight': {'airline': 'United',\n  'departure_airport': 'San Francisco International Airport',\n  'departure_date': 'Tuesday, March 24',\n  'departure_time': '1:39 PM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'Ronald Reagan Washington National Airport',\n  'arrival_date': 'Tuesday, March 24',\n  'arrival_time': '9:45 PM',\n  'duration_minutes': 306,\n  'duration_str': '5 hr 6 min',\n  'carry_on_bags': 1,\n  'checked_bags': 0},\n 'return_flight': {'airline': 'United',\n  'departure_airport': 'Ronald Reagan Washington National Airport',\n  'departure_date': 'Tuesday, March 31',\n  'departure_time': '7:30 AM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'San Francisco International Airport',\n  'arrival_date': 'Tuesday, March 31',\n  'arrival_time': '10:42 AM',\n  'duration_minutes': 372,\n  'duration_str': '6 hr 12 min',\n  'carry_on_bags': 1,\n  'checked_bags': 0},\n 'price': 515,\n 'price_classification': 'typical',\n 'price_difference': 0,\n 'price_relativity': 0.0,\n 'status': 'Ran successfully.',\n 'url': 'https://www.google.com/travel/flights/booking?tfs=CBwQAhpAEgoyMDI2LTAzLTI0IiAKA1NGTxIKMjAyNi0wMy0yNBoDRENBKgJVQTIEMjM4NmoHCAESA1NGT3IHCAESA0RDQRo_EgoyMDI2LTAzLTMxIh8KA0RDQRIKMjAyNi0wMy0zMRoDU0ZPKgJVQTIDMzY5agcIARIDRENBcgcIARIDU0ZPQAFIAXABggELCP___________wGYAQHIAQE&amp;tfu=CmxDalJJT1U0eU5FVmxhekUyWWpSQlEwMVFTMEZDUnkwdExTMHRMUzB0TFhaMGIzWXhPRUZCUVVGQlIyMU1TMEZKVEZGM2NWbEJFZ1ZWUVRNMk9Sb0xDSk9TQXhBQ0dnTlZVMFE0SEhDVGtnTT0SAggAIgYKATAKATE'}</pre> <p>This returns a nonstop flight on United.</p> <p>The <code>'price_classification'</code> is 'typical' so a <code>'price_difference'</code> of $0 is returned.</p>"},{"location":"tutorial/simple_request/#tutorial-simple-flight-request","title":"Tutorial: Simple Flight Request\u00b6","text":"<p>The <code>google_flights_scraper</code> package can be used to simulate and end-to-end process of selecting the best departure and return flight as determined and listed by Google Flights.</p>"},{"location":"tutorial/simple_request/#set-up","title":"Set Up\u00b6","text":""},{"location":"tutorial/simple_request/#request-format","title":"Request Format\u00b6","text":""},{"location":"tutorial/simple_request/#example-1-domestic-economy","title":"Example 1: Domestic Economy\u00b6","text":"<p>Below is an example request for a Domestic Economy flight leaving from LAX and arriving at one of the New York airports.</p> <p>Typical wait time is ~20 seconds.</p>"},{"location":"tutorial/simple_request/#example-2-international-premium-economy","title":"Example 2: International Premium Economy\u00b6","text":"<p>Below is an example request for a International Premium Economy flight leaving from New York and arriving in Tokyo.</p>"},{"location":"tutorial/simple_request/#example-3-domestic-economy-excluding-basic","title":"Example 3: Domestic Economy (excluding Basic)\u00b6","text":"<p>Below is an example request for a Domestic Economy (excluding Basic) flight leaving from SFO and arriving at DCA.</p> <p>Economy (excluding Basic) excludes budget airlines like Frontier, Spirit, and Breeze from its listings.</p>"}]}