{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Google Flights Scraper","text":"<p>Welcome to the <code>google_flights_scraper</code> documentation!</p>"},{"location":"#overview","title":"Overview","text":"<p>This Selenium scraper interacts with Google Flights to select the \"best\" flight options, and collect flight information including prices, times, airlines, connections, and price relativity.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Simple Request Tutorial</li> <li>Batch Request Tutorial</li> <li>API Reference</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>google_flights_scraper<ul> <li>batch_scraper</li> <li>config_browser</li> <li>interactions</li> <li>parsers</li> <li>scraper</li> <li>validators</li> </ul> </li> </ul>"},{"location":"reference/google_flights_scraper/","title":"google_flights_scraper","text":"<p>A Python-based Selenium scraper for Google Flights.</p>"},{"location":"reference/google_flights_scraper/#google_flights_scraper.GoogleFlightsScraper","title":"<code>GoogleFlightsScraper</code>","text":"<p>Web scraper for Google Flights.</p> Source code in <code>src/google_flights_scraper/scraper.py</code> <pre><code>class GoogleFlightsScraper:\n    \"\"\"Web scraper for Google Flights.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the scraper with airport codes data.\"\"\"\n        package_dir = Path(__file__).parent.parent.parent\n        csv_path = package_dir / \"data\" / \"airport_codes.csv\"\n        self.airport_codes_df = pd.read_csv(csv_path)\n        self.driver = setup_chrome_driver(headless=True)\n        self.wait_time = DEFAULT_WAIT_TIME\n        self.wait = WebDriverWait(self.driver, self.wait_time)\n\n    def _create_result_structure(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n    ):\n        \"\"\"Create the initial result structure for storing flight data.\n\n        Args:\n            departure_code (str): IATA code or cirty for departure airport\n            departure_country (str): Country of departure airport or city\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country of arrival airport or city\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class string\n\n        Returns:\n            dict: Empty result structure\n        \"\"\"\n        return {\n            \"inputs\": {\n                \"departure_airport\": departure_code,\n                \"departure_country\": departure_country,\n                \"arrival_airport\": arrival_code,\n                \"arrival_country\": arrival_country,\n                \"departure_date\": start_date,\n                \"return_date\": end_date,\n                \"seat_class\": seat_class,\n            },\n            \"departure_flight\": create_empty_flight_info(),\n            \"return_flight\": create_empty_flight_info(),\n            \"price\": None,\n            \"price_classification\": None,\n            \"price_difference\": None,\n            \"price_relativity\": None,\n            \"status\": None,\n            \"url\": None,\n        }\n\n    def _validate_inputs(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        seat_class: str,\n        start_date: str,\n        end_date: str,\n        export_path: str | None,\n    ):\n        \"\"\"Validate all input parameters.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country for departure airport\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country for arrival airport\n            seat_class (str): Seat class string\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            export_path (str | None): Path to export, required if export is True\n\n        Returns:\n            bool: True if flight is domestic US\n        \"\"\"\n        # Validate airport codes\n        for code in [departure_code, arrival_code]:\n            validate_airport_code(code, self.airport_codes_df)\n\n        # Determine if domestic US flight\n        is_domestic_us = is_domestic_us_flight(\n            departure_country,\n            arrival_country,\n            self.airport_codes_df,\n        )\n\n        # Validate seat class\n        validate_seat_class(seat_class, is_domestic_us)\n\n        # Validate dates\n        validate_dates(start_date, end_date)\n\n        # Validate export params\n        validate_export_params(export_path)\n\n        return is_domestic_us\n\n    def _fill_search_form(\n        self,\n        departure_code: str,\n        arrival_code: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n        is_domestic_us: bool,\n    ):\n        \"\"\"Fill out the Google Flights search form.\n\n        Args:\n            departure_code (str): IATA code for departure airport\n            arrival_code (str): IATA code for arrival airport\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class string\n            is_domestic_us (bool): Whether flight is domestic US\n        \"\"\"\n        # Enter airports\n        enter_airports(self.wait, departure_code, arrival_code)\n\n        # Enter dates\n        enter_dates(self.wait, start_date, end_date)\n\n        # Select seat class\n        select_seat_class(self.wait, seat_class, is_domestic_us)\n\n        # Click search button\n        press_search_button(self.wait)\n\n    def _find_flight_with_retry(\n        self,\n        result: dict,\n        key: str,\n        max_retries: int = 3,\n        sleep_s: float = 0.5,\n    ):\n        \"\"\"Find best flight element with retry and extract details.\n\n        Args:\n            result (dict): Dictionary to populate with flight details\n            key (str): Dict key to add data to (departure or return flight)\n            max_retries (int): Number of times to retry selecting element\n            sleep_s (float): How long to sleep (seconds) in between each try\n\n        Returns:\n            WebElement | None\n        \"\"\"\n        for attempt in range(max_retries):\n            try:\n                flight = find_and_select_best_flight(\n                    self.wait,\n                    self.driver,\n                    self.wait_time,\n                )\n\n                if flight is None:\n                    return None, f\"No {key} found.\"\n\n                result[key] = extract_flight_details(flight)\n                flight.click()\n                return None\n\n            except StaleElementReferenceException:\n                if attempt == max_retries - 1:\n                    return f\"No {key} found.\"\n                time.sleep(sleep_s)\n\n    def _select_best_flights(self, result: dict):\n        \"\"\"Select the best departure and return flights and extract details.\n\n        Args:\n            result (dict): Dictionary to populate with flight details\n\n        Returns:\n            tuple: (updated result dictionary, success status message)\n        \"\"\"\n        # Select Departure\n        err = self._find_flight_with_retry(\n            result,\n            key=\"departure_flight\",\n        )\n        if err:\n            return result, err\n\n        # Select Return\n        err = self._find_flight_with_retry(\n            result,\n            key=\"return_flight\",\n        )\n        if err:\n            return result, err\n\n        # Extract price from final booking page\n        result[\"price\"] = extract_final_price(self.wait, self.driver, self.wait_time)\n\n        # Capture the final page URL\n        result[\"url\"] = self.driver.current_url\n\n        return result, \"Ran successfully.\"\n\n    def _calc_price_rel(self, price: int, price_difference: int | None):\n        \"\"\"Calculate price relaticity (% discount).\n\n        Args:\n            price (int): Final flight price\n            price_difference (int | None): If found, how much cheaper flight is than usual\n\n        Returns:\n            float: Percentage discount\n        \"\"\"\n        if price_difference is not None:\n            return round(float(price_difference / (price + price_difference)), 4)\n        else:\n            return None\n\n    def _export_data(self, result: dict, export_path: str):\n        \"\"\"Export dict to file based on extension.\n\n        Args:\n            result (dict): Resulting dictionary after scraping\n            export_path (str): Path to export file to\n        \"\"\"\n        if export_path.endswith(\".json\"):\n            json_output = json.dumps(result, indent=2)\n            with open(export_path, \"w\") as f:\n                f.write(json_output)\n        elif export_path.endswith(\".csv\"):\n            df = pd.json_normalize(result, sep=\"_\")\n            df.to_csv(export_path, index=False)\n\n    def scrape_flight(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n        export_path: str | None = None,\n    ):\n        \"\"\"Scrape Google Flights for specified route and parameters.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country for departure airport\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country for arrival airport\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)\n            export_path (str | None): Path to export, required if export is True\n\n        Returns:\n            dict: Complete flight information as dictionary\n        \"\"\"\n        # Initialize result structure\n        result = self._create_result_structure(\n            departure_code,\n            departure_country,\n            arrival_code,\n            arrival_country,\n            start_date,\n            end_date,\n            seat_class,\n        )\n\n        try:\n            # Validate inputs\n            is_domestic_us = self._validate_inputs(\n                departure_code,\n                departure_country,\n                arrival_code,\n                arrival_country,\n                seat_class,\n                start_date,\n                end_date,\n                export_path,\n            )\n\n            # Navigate to Google Flights\n            self.driver.get(\"https://www.google.com/travel/flights\")\n\n            # Fill search form\n            self._fill_search_form(\n                departure_code,\n                arrival_code,\n                start_date,\n                end_date,\n                seat_class,\n                is_domestic_us,\n            )\n\n            # Select best flights and extract details\n            result, status = self._select_best_flights(result)\n\n            # Extract price difference\n            if status == \"Ran successfully.\":\n                (result[\"price_classification\"], result[\"price_difference\"]) = (\n                    extract_price_relativity(self.wait, self.driver, self.wait_time)\n                )\n\n            # Calculate price relativity\n            result[\"price_relativity\"] = self._calc_price_rel(\n                result[\"price\"], result[\"price_difference\"]\n            )\n\n        except Exception as e:\n            print(f\"Error scraping flight: {e}\")\n            status = f\"Error: {str(e)}\"\n        finally:\n            # Close the driver\n            self.driver.quit()\n            time.sleep(1)\n\n        # Update status\n        result[\"status\"] = status\n\n        # Export\n        if export_path:\n            self._export_data(result, export_path)\n\n        return result\n</code></pre>"},{"location":"reference/google_flights_scraper/#google_flights_scraper.GoogleFlightsScraper.scrape_flight","title":"<code>scrape_flight(departure_code, departure_country, arrival_code, arrival_country, start_date, end_date, seat_class, export_path=None)</code>","text":"<p>Scrape Google Flights for specified route and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_code</code> <code>str</code> <p>IATA code or city for arrival airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <code>seat_class</code> <code>str</code> <p>Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)</p> required <code>export_path</code> <code>str | None</code> <p>Path to export, required if export is True</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Complete flight information as dictionary</p> Source code in <code>src/google_flights_scraper/scraper.py</code> <pre><code>def scrape_flight(\n    self,\n    departure_code: str,\n    departure_country: str,\n    arrival_code: str,\n    arrival_country: str,\n    start_date: str,\n    end_date: str,\n    seat_class: str,\n    export_path: str | None = None,\n):\n    \"\"\"Scrape Google Flights for specified route and parameters.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_code (str): IATA code or city for arrival airport\n        arrival_country (str): Country for arrival airport\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n        seat_class (str): Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)\n        export_path (str | None): Path to export, required if export is True\n\n    Returns:\n        dict: Complete flight information as dictionary\n    \"\"\"\n    # Initialize result structure\n    result = self._create_result_structure(\n        departure_code,\n        departure_country,\n        arrival_code,\n        arrival_country,\n        start_date,\n        end_date,\n        seat_class,\n    )\n\n    try:\n        # Validate inputs\n        is_domestic_us = self._validate_inputs(\n            departure_code,\n            departure_country,\n            arrival_code,\n            arrival_country,\n            seat_class,\n            start_date,\n            end_date,\n            export_path,\n        )\n\n        # Navigate to Google Flights\n        self.driver.get(\"https://www.google.com/travel/flights\")\n\n        # Fill search form\n        self._fill_search_form(\n            departure_code,\n            arrival_code,\n            start_date,\n            end_date,\n            seat_class,\n            is_domestic_us,\n        )\n\n        # Select best flights and extract details\n        result, status = self._select_best_flights(result)\n\n        # Extract price difference\n        if status == \"Ran successfully.\":\n            (result[\"price_classification\"], result[\"price_difference\"]) = (\n                extract_price_relativity(self.wait, self.driver, self.wait_time)\n            )\n\n        # Calculate price relativity\n        result[\"price_relativity\"] = self._calc_price_rel(\n            result[\"price\"], result[\"price_difference\"]\n        )\n\n    except Exception as e:\n        print(f\"Error scraping flight: {e}\")\n        status = f\"Error: {str(e)}\"\n    finally:\n        # Close the driver\n        self.driver.quit()\n        time.sleep(1)\n\n    # Update status\n    result[\"status\"] = status\n\n    # Export\n    if export_path:\n        self._export_data(result, export_path)\n\n    return result\n</code></pre>"},{"location":"reference/google_flights_scraper/batch_scraper/","title":"batch_scraper","text":"<p>Batch scraping functions for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/batch_scraper/#google_flights_scraper.batch_scraper.scrape_date_range","title":"<code>scrape_date_range(departure_code, departure_country, arrival_code, arrival_country, start_date_range, end_date_range, min_trip_length, max_trip_length, seat_class, output_path=None, delay_seconds=3.0)</code>","text":"<p>Scrape all date combinations within a date range.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_code</code> <code>str</code> <p>IATA code or city for arrival airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>start_date_range</code> <code>str</code> <p>Earliest departure date in MM/DD/YYYY format</p> required <code>end_date_range</code> <code>str</code> <p>Latest possible return date in MM/DD/YYYY format</p> required <code>min_trip_length</code> <code>int</code> <p>Minimum trip length in days</p> required <code>max_trip_length</code> <code>int</code> <p>Maximum trip length in days</p> required <code>seat_class</code> <code>str</code> <p>Seat class</p> required <code>output_path</code> <code>str | None</code> <p>Optional path to save CSV output</p> <code>None</code> <code>delay_seconds</code> <code>float</code> <p>Delay between searches in seconds (default 3.0)</p> <code>3.0</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Results for all date combinations</p> Source code in <code>src/google_flights_scraper/batch_scraper.py</code> <pre><code>def scrape_date_range(\n    departure_code: str,\n    departure_country: str,\n    arrival_code: str,\n    arrival_country: str,\n    start_date_range: str,\n    end_date_range: str,\n    min_trip_length: int,\n    max_trip_length: int,\n    seat_class: str,\n    output_path: str | None = None,\n    delay_seconds: float = 3.0,\n):\n    \"\"\"Scrape all date combinations within a date range.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_code (str): IATA code or city for arrival airport\n        arrival_country (str): Country for arrival airport\n        start_date_range (str): Earliest departure date in MM/DD/YYYY format\n        end_date_range (str): Latest possible return date in MM/DD/YYYY format\n        min_trip_length (int): Minimum trip length in days\n        max_trip_length (int): Maximum trip length in days\n        seat_class (str): Seat class\n        output_path (str | None): Optional path to save CSV output\n        delay_seconds (float): Delay between searches in seconds (default 3.0)\n\n    Returns:\n        DataFrame: Results for all date combinations\n    \"\"\"\n    # Parse dates\n    start_range = datetime.strptime(start_date_range, \"%m/%d/%Y\")\n    end_range = datetime.strptime(end_date_range, \"%m/%d/%Y\")\n\n    # Generate all valid date combinations\n    date_combinations = []\n    current_departure = start_range\n\n    while current_departure &lt;= end_range:\n        for trip_length in range(min_trip_length, max_trip_length + 1):\n            return_date = current_departure + timedelta(days=trip_length)\n\n            # Only include if return date is within range\n            if return_date &lt;= end_range:\n                date_combinations.append({\n                    \"departure\": current_departure.strftime(\"%m/%d/%Y\"),\n                    \"return\": return_date.strftime(\"%m/%d/%Y\"),\n                    \"trip_length\": trip_length,\n                })\n\n        current_departure += timedelta(days=1)\n\n    results = []\n    total = len(date_combinations)\n\n    for i, combo in enumerate(date_combinations, 1):\n        print(f\"[{i}/{total}] Searching {combo['departure']} \u2192 {combo['return']}...\")\n        try:\n            scraper = GoogleFlightsScraper()\n            result = scraper.scrape_flight(\n                departure_code=departure_code,\n                departure_country=departure_country,\n                arrival_code=arrival_code,\n                arrival_country=arrival_country,\n                start_date=str(combo[\"departure\"]),\n                end_date=str(combo[\"return\"]),\n                seat_class=seat_class,\n            )\n\n            # Flatten the result dict for CSV\n            flat_result = _flatten_result(result)\n            flat_result[\"trip_length_days\"] = combo[\"trip_length\"]\n            results.append(flat_result)\n\n        except Exception as e:\n            print(f\"  Error: {e}\")\n            # Add a failed result\n            results.append({\n                \"departure_airport\": departure_code,\n                \"departure_country\": departure_country,\n                \"arrival_airport\": arrival_code,\n                \"arrival_country\": arrival_country,\n                \"departure_date\": combo[\"departure\"],\n                \"return_date\": combo[\"return\"],\n                \"trip_length_days\": combo[\"trip_length\"],\n                \"seat_class\": seat_class,\n                \"status\": f\"Error: {str(e)}\",\n                \"price\": None,\n            })\n\n        # Delay before next search (except after last one)\n        if i &lt; total and delay_seconds &gt; 0:\n            time.sleep(delay_seconds)\n\n    # Convert to DataFrame\n    df = pd.DataFrame(results)\n\n    # Sort by price_relativity (largest to smallest, NAs last)\n    if \"price_relativity\" in df.columns:\n        df = df.sort_values(\"price_relativity\", ascending=False, na_position=\"last\")\n\n    # Save to CSV\n    if output_path:\n        df.to_csv(output_path, index=False)\n    successful = df[\"status\"].str.contains(\"success\", case=False, na=False).sum()\n    print(f\"Total searches: {total}, Successful: {successful}\")\n\n    return df\n</code></pre>"},{"location":"reference/google_flights_scraper/batch_scraper/#google_flights_scraper.batch_scraper.scrape_multiple_destinations","title":"<code>scrape_multiple_destinations(departure_code, departure_country, arrival_codes, arrival_countries, start_date, end_date, seat_classes, output_path=None, delay_seconds=3.0)</code>","text":"<p>Scrape multiple destinations with fixed dates.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_codes</code> <code>list[str]</code> <p>List of IATA codes or cities for arrival airports</p> required <code>arrival_countries</code> <code>list[str]</code> <p>List of countries (same length as arrival_codes)</p> required <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <code>seat_classes</code> <code>list[str]</code> <p>List of seat classes (same length as arrival_codes)</p> required <code>output_path</code> <code>str | None</code> <p>Optional path to save CSV output</p> <code>None</code> <code>delay_seconds</code> <code>float</code> <p>Delay between searches in seconds (default 3.0)</p> <code>3.0</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Results for all destinations</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If arrival_codes, arrival_countries, and seat_classes are not the same length</p> Source code in <code>src/google_flights_scraper/batch_scraper.py</code> <pre><code>def scrape_multiple_destinations(\n    departure_code: str,\n    departure_country: str,\n    arrival_codes: list[str],\n    arrival_countries: list[str],\n    start_date: str,\n    end_date: str,\n    seat_classes: list[str],\n    output_path: str | None = None,\n    delay_seconds: float = 3.0,\n):\n    \"\"\"Scrape multiple destinations with fixed dates.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_codes (list[str]): List of IATA codes or cities for arrival airports\n        arrival_countries (list[str]): List of countries (same length as arrival_codes)\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n        seat_classes (list[str]): List of seat classes (same length as arrival_codes)\n        output_path (str | None): Optional path to save CSV output\n        delay_seconds (float): Delay between searches in seconds (default 3.0)\n\n    Returns:\n        DataFrame: Results for all destinations\n\n    Raises:\n        ValueError: If arrival_codes, arrival_countries, and seat_classes are not the same length\n    \"\"\"\n    if len(arrival_codes) != len(arrival_countries):\n        raise ValueError(\"arrival_codes and arrival_countries must have same length\")\n\n    if len(arrival_codes) != len(seat_classes):\n        raise ValueError(\"arrival_codes and seat_classes must have same length\")\n\n    results = []\n    total = len(arrival_codes)\n\n    for i, (arrival_code, arrival_country, seat_class) in enumerate(\n        zip(arrival_codes, arrival_countries, seat_classes, strict=True), 1\n    ):\n        print(f\"[{i}/{total}] Searching {departure_code} \u2192 {arrival_code} ({seat_class})...\")\n\n        try:\n            scraper = GoogleFlightsScraper()\n            result = scraper.scrape_flight(\n                departure_code=departure_code,\n                departure_country=departure_country,\n                arrival_code=arrival_code,\n                arrival_country=arrival_country,\n                start_date=start_date,\n                end_date=end_date,\n                seat_class=seat_class,\n            )\n\n            # Flatten the result dict for CSV\n            flat_result = _flatten_result(result)\n            results.append(flat_result)\n\n        except Exception as e:\n            print(f\"  Error: {e}\")\n            # Add a failed result\n            results.append({\n                \"departure_airport\": departure_code,\n                \"departure_country\": departure_country,\n                \"arrival_airport\": arrival_code,\n                \"arrival_country\": arrival_country,\n                \"departure_date\": start_date,\n                \"return_date\": end_date,\n                \"seat_class\": seat_class,\n                \"status\": f\"Error: {str(e)}\",\n                \"price\": None,\n            })\n\n        # Delay before next search (except after last one)\n        if i &lt; total and delay_seconds &gt; 0:\n            time.sleep(delay_seconds)\n\n    # Convert to DataFrame\n    df = pd.DataFrame(results)\n\n    # Sort by price_relativity (largest to smallest, NAs last)\n    if \"price_relativity\" in df.columns:\n        df = df.sort_values(\"price_relativity\", ascending=False, na_position=\"last\")\n\n    # Save to CSV\n    if output_path:\n        df.to_csv(output_path, index=False)\n    successful = df[\"status\"].str.contains(\"success\", case=False, na=False).sum()\n    print(f\"Total searches: {total}, Successful: {successful}\")\n\n    return df\n</code></pre>"},{"location":"reference/google_flights_scraper/config_browser/","title":"config_browser","text":"<p>Configuration constants and browser setup for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/config_browser/#google_flights_scraper.config_browser.setup_chrome_driver","title":"<code>setup_chrome_driver(headless=True)</code>","text":"<p>Setup Chrome driver with appropriate options.</p> <p>Parameters:</p> Name Type Description Default <code>headless</code> <code>bool</code> <p>Whether to run Chrome in headless mode</p> <code>True</code> <p>Returns:</p> Type Description <p>webdriver.Chrome: Configured Chrome driver instance</p> Source code in <code>src/google_flights_scraper/config_browser.py</code> <pre><code>def setup_chrome_driver(headless: bool = True):\n    \"\"\"Setup Chrome driver with appropriate options.\n\n    Args:\n        headless (bool): Whether to run Chrome in headless mode\n\n    Returns:\n        webdriver.Chrome: Configured Chrome driver instance\n    \"\"\"\n    chrome_options = Options()\n    if headless:\n        chrome_options.add_argument(\"--headless\")\n    chrome_options.add_argument(\"--no-sandbox\")\n    chrome_options.add_argument(\"--disable-dev-shm-usage\")\n    chrome_options.add_argument(\"--disable-blink-features=AutomationControlled\")\n    chrome_options.add_argument(\n        \"--user-agent=\"\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n        \"AppleWebKit/537.36 (KHTML, like Gecko) \"\n        \"Chrome/120.0.0.0 Safari/537.36\",\n    )\n    chrome_options.add_argument(\"--disable-gpu\")\n    chrome_options.add_argument(\"--remote-debugging-port=9222\")\n    chrome_options.add_argument(\"--disable-software-rasterizer\")\n\n    driver = webdriver.Chrome(options=chrome_options)\n    driver.maximize_window()\n\n    return driver\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/","title":"interactions","text":"<p>Page interaction functions for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_airports","title":"<code>enter_airports(wait, airport_code_from, airport_code_to)</code>","text":"<p>Enter both departure and arrival airport codes.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>airport_code_from</code> <code>str</code> <p>IATA code for departure airport</p> required <code>airport_code_to</code> <code>str</code> <p>IATA code for arrival airport</p> required Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def enter_airports(wait: WebDriverWait, airport_code_from: str, airport_code_to: str):\n    \"\"\"Enter both departure and arrival airport codes.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        airport_code_from (str): IATA code for departure airport\n        airport_code_to (str): IATA code for arrival airport\n    \"\"\"\n    enter_departure_airport(wait, airport_code_from)\n    enter_arrival_airport(wait, airport_code_to)\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_arrival_airport","title":"<code>enter_arrival_airport(wait, airport_code)</code>","text":"<p>Enter arrival airport code into input field.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>airport_code</code> <code>str</code> <p>IATA code for arrival airport</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def enter_arrival_airport(wait: WebDriverWait, airport_code: str):\n    \"\"\"Enter arrival airport code into input field.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        airport_code (str): IATA code for arrival airport\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        to_input = wait.until(\n            EC.presence_of_element_located(\n                (By.XPATH, \"//input[@aria-label='Where to? ']\"),\n            )\n        )\n    except TimeoutException as e:\n        raise Exception(\"Error entering arrival airport:\") from e\n\n    to_input.click()\n    to_popup = wait.until(\n        EC.presence_of_all_elements_located((\n            By.XPATH,\n            \"//input[contains(@aria-label,'Where to?')]\",\n        ))\n    )[1]\n    to_popup.clear()\n    to_popup.send_keys(airport_code)\n    to_popup.send_keys(Keys.DOWN)\n    to_popup.send_keys(Keys.ENTER)\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_dates","title":"<code>enter_dates(wait, date_from, date_to)</code>","text":"<p>Enter both departure and return dates.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>date_from</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>date_to</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def enter_dates(wait: WebDriverWait, date_from: str, date_to: str):\n    \"\"\"Enter both departure and return dates.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        date_from (str): Departure date in MM/DD/YYYY format\n        date_to (str): Return date in MM/DD/YYYY format\n    \"\"\"\n    enter_departure_date(wait, date_from)\n    enter_return_date(wait, date_to)\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_departure_airport","title":"<code>enter_departure_airport(wait, airport_code)</code>","text":"<p>Enter departure airport code into input field.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>airport_code</code> <code>str</code> <p>IATA code for departure airport</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def enter_departure_airport(wait: WebDriverWait, airport_code: str):\n    \"\"\"Enter departure airport code into input field.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        airport_code (str): IATA code for departure airport\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        from_input = wait.until(\n            EC.presence_of_element_located(\n                (By.XPATH, \"//input[@aria-label='Where from?']\"),\n            )\n        )\n    except TimeoutException as e:\n        raise Exception(\"Error entering departure airport:\") from e\n\n    from_input.click()\n    time.sleep(1)\n    from_popup = wait.until(\n        EC.presence_of_all_elements_located((\n            By.XPATH,\n            \"//input[contains(@aria-label,'Where else?')]\",\n        ))\n    )[1]\n    from_popup.clear()\n    from_popup.send_keys(airport_code)\n    from_popup.send_keys(Keys.DOWN)\n    from_popup.send_keys(Keys.ENTER)\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_departure_date","title":"<code>enter_departure_date(wait, date_from)</code>","text":"<p>Enter departure date into input field.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>date_from</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def enter_departure_date(wait: WebDriverWait, date_from: str):\n    \"\"\"Enter departure date into input field.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        date_from (str): Departure date in MM/DD/YYYY format\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        departure_input = wait.until(\n            EC.presence_of_element_located(\n                (By.XPATH, \"//input[@aria-label='Departure']\"),\n            )\n        )\n    except TimeoutException as e:\n        raise Exception(\"Error entering departure date:\") from e\n\n    departure_input.click()\n    time.sleep(1)\n\n    try:\n        departure_popup = wait.until(\n            EC.presence_of_all_elements_located(\n                (By.XPATH, \"//input[@aria-label='Departure']\"),\n            )\n        )[1]\n    except TimeoutException as e:\n        raise Exception(\"Error entering departure date:\") from e\n\n    departure_popup.send_keys(date_from)\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.enter_return_date","title":"<code>enter_return_date(wait, date_to)</code>","text":"<p>Enter return date into input field.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>date_to</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def enter_return_date(wait: WebDriverWait, date_to: str):\n    \"\"\"Enter return date into input field.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        date_to (str): Return date in MM/DD/YYYY format\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    try:\n        return_popup = wait.until(\n            EC.presence_of_all_elements_located(\n                (By.XPATH, \"//input[@aria-label='Return']\"),\n            )\n        )[1]\n    except TimeoutException as e:\n        raise Exception(\"Error entering return date:\") from e\n\n    return_popup.send_keys(date_to)\n    return_popup.send_keys(Keys.ENTER)\n    return_popup.send_keys(Keys.ENTER)\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.find_and_select_best_flight","title":"<code>find_and_select_best_flight(wait, driver, timeout)</code>","text":"<p>Find and click the best (first) flight option on the page.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>driver</code> <code>Chrome</code> <p>Selenium WebDriver instance</p> required <code>timeout</code> <code>int</code> <p>Timeout for waiting operations</p> required <p>Returns:</p> Name Type Description <code>WebElement</code> <p>The selected flight element, or None if not found</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def find_and_select_best_flight(wait: WebDriverWait, driver: Chrome, timeout: int):\n    \"\"\"Find and click the best (first) flight option on the page.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        driver (Chrome): Selenium WebDriver instance\n        timeout (int): Timeout for waiting operations\n\n    Returns:\n        WebElement: The selected flight element, or None if not found\n    \"\"\"\n    # Wait for page to fully load\n    wait_until_class_stable(\n        driver,\n        (By.XPATH, \"//div[@role='progressbar']\"),\n        stable_duration=2.0,\n        timeout=timeout,\n    )\n\n    # Find best flight (first option)\n    try:\n        best_flight = wait.until(\n            EC.presence_of_element_located(\n                (By.XPATH, \"//button[@aria-label='Select flight']/ancestor::li\"),\n            )\n        )\n    except TimeoutException:\n        return None\n\n    return best_flight\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.press_search_button","title":"<code>press_search_button(wait)</code>","text":"<p>Press the search button to initiate flight search.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If search button cannot be found or clicked</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def press_search_button(wait: WebDriverWait):\n    \"\"\"Press the search button to initiate flight search.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n\n    Raises:\n        Exception: If search button cannot be found or clicked\n    \"\"\"\n    try:\n        search_button = wait.until(\n            EC.presence_of_element_located(\n                (By.XPATH, '//button[@aria-label=\"Search\"]'),\n            )\n        )\n    except TimeoutException as e:\n        raise Exception(\"Error pressing search button:\") from e\n    search_button.click()\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.select_seat_class","title":"<code>select_seat_class(wait, seat_class, is_domestic_us)</code>","text":"<p>Select seat class from dropdown.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>seat_class</code> <code>str</code> <p>Seat class to select</p> required <code>is_domestic_us</code> <code>bool</code> <p>Whether flight is domestic US</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If elements cannot be found or interacted with</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def select_seat_class(wait: WebDriverWait, seat_class: str, is_domestic_us: bool):\n    \"\"\"Select seat class from dropdown.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        seat_class (str): Seat class to select\n        is_domestic_us (bool): Whether flight is domestic US\n\n    Raises:\n        Exception: If elements cannot be found or interacted with\n    \"\"\"\n    # Find and click dropdown\n    try:\n        class_dropdown = wait.until(\n            EC.presence_of_element_located(\n                (\n                    By.XPATH,\n                    \"//div[@role='combobox' and .//span[@aria-label='Change seating class.']]\",\n                ),\n            )\n        )\n    except TimeoutException as e:\n        raise Exception(\"Error selecting seat class:\") from e\n    class_dropdown.click()\n\n    # Get options and select\n    try:\n        class_options = wait.until(\n            EC.presence_of_all_elements_located(\n                (By.XPATH, \"//li[@role='option']\"),\n            )\n        )\n    except TimeoutException as e:\n        raise Exception(\"Error selecting seat class:\") from e\n\n    option_index = SEAT_CLASS_OPTION_MAPPING[is_domestic_us][seat_class.lower()]\n    class_options[option_index].click()\n</code></pre>"},{"location":"reference/google_flights_scraper/interactions/#google_flights_scraper.interactions.wait_until_class_stable","title":"<code>wait_until_class_stable(driver, locator, stable_duration=2.0, timeout=20)</code>","text":"<p>Wait until an element's class attribute stops changing.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>Chrome</code> <p>Selenium WebDriver instance</p> required <code>locator</code> <code>tuple</code> <p>Tuple of (By.*, 'selector') e.g., (By.ID, 'my-div')</p> required <code>stable_duration</code> <code>float</code> <p>How long (in seconds) the class must remain unchanged</p> <code>2.0</code> <code>timeout</code> <code>int</code> <p>Maximum time to wait before raising TimeoutException</p> <code>20</code> <p>Raises:</p> Type Description <code>TimeoutException</code> <p>If element class does not stabilize within timeout</p> Source code in <code>src/google_flights_scraper/interactions.py</code> <pre><code>def wait_until_class_stable(\n    driver: Chrome, locator: tuple, stable_duration: float = 2.0, timeout: int = 20\n):\n    \"\"\"Wait until an element's class attribute stops changing.\n\n    Args:\n        driver (Chrome): Selenium WebDriver instance\n        locator (tuple): Tuple of (By.*, 'selector') e.g., (By.ID, 'my-div')\n        stable_duration (float): How long (in seconds) the class must remain unchanged\n        timeout (int): Maximum time to wait before raising TimeoutException\n\n    Raises:\n        TimeoutException: If element class does not stabilize within timeout\n    \"\"\"\n    start_time = time.time()\n    previous_class = None\n    first_read = True\n    stable_since = None\n\n    while True:\n        if time.time() - start_time &gt; timeout:\n            raise TimeoutException(f\"Element class did not stabilize within {timeout} seconds\")\n\n        try:\n            element = driver.find_element(*locator)\n            current_class = element.get_attribute(\"class\")\n\n            # On first read, just store the class\n            if first_read:\n                previous_class = current_class\n                stable_since = time.time()\n                first_read = False\n            elif current_class == previous_class:\n                if stable_since is not None:\n                    # Class hasn't changed, check if stable long enough\n                    if time.time() - stable_since &gt;= stable_duration:\n                        # do one last small wait\n                        time.sleep(1)\n                        break\n            else:\n                # Class changed, reset the timer\n                previous_class = current_class\n                stable_since = time.time()\n\n            time.sleep(0.1)  # Check every 100ms\n\n        except NoSuchElementException:\n            # Element not found yet, keep waiting\n            first_read = True\n            previous_class = None\n            stable_since = None\n            time.sleep(0.1)\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/","title":"parsers","text":"<p>Data extraction and parsing functions for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.create_empty_flight_info","title":"<code>create_empty_flight_info()</code>","text":"<p>Create an empty flight info dictionary structure.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Empty flight info structure with all fields set to None or empty lists</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def create_empty_flight_info():\n    \"\"\"Create an empty flight info dictionary structure.\n\n    Returns:\n        dict: Empty flight info structure with all fields set to None or empty lists\n    \"\"\"\n    return {\n        \"airline\": None,\n        \"departure_airport\": None,\n        \"departure_date\": None,\n        \"departure_time\": None,\n        \"num_stops\": None,\n        \"connection_airports\": [],\n        \"layover_durations\": [],\n        \"arrival_airport\": None,\n        \"arrival_date\": None,\n        \"arrival_time\": None,\n        \"duration_minutes\": None,\n        \"duration_str\": None,\n        \"carry_on_bags\": None,\n        \"checked_bags\": None,\n    }\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_airline","title":"<code>extract_airline(flight_description)</code>","text":"<p>Extract airline from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Airline name or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_airline(flight_description: str):\n    \"\"\"Extract airline from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        str: Airline name or None\n    \"\"\"\n    if m := re.search(r\"flight with ([^.]+)\", flight_description):\n        return m.group(1).strip()\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_arrival_info","title":"<code>extract_arrival_info(flight_description)</code>","text":"<p>Extract arrival airport, time, and date from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(airport, time, date) or (None, None, None)</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_arrival_info(flight_description: str):\n    \"\"\"Extract arrival airport, time, and date from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (airport, time, date) or (None, None, None)\n    \"\"\"\n    arr_pattern = (\n        r\"arrives at (.*?) at (\\d{1,2}:\\d{2}\\s?[AP]M) \"\n        r\"on ([A-Za-z]+, [A-Za-z]+ \\d{1,2})\"\n    )\n    if m := re.search(arr_pattern, flight_description):\n        return m.group(1).strip(), m.group(2).strip(), m.group(3).strip()\n    return None, None, None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_baggage_info","title":"<code>extract_baggage_info(flight_description)</code>","text":"<p>Extract carry-on and checked bag information from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(carry_on_bags, checked_bags) as integers or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_baggage_info(flight_description: str):\n    \"\"\"Extract carry-on and checked bag information from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (carry_on_bags, checked_bags) as integers or None\n    \"\"\"\n    carry_on_bags = None\n    checked_bags = None\n\n    if m := re.search(r\"(\\d+) carry-on bag\", flight_description):\n        carry_on_bags = int(m.group(1))\n\n    if m := re.search(r\"(\\d+) checked bags\", flight_description):\n        checked_bags = int(m.group(1))\n\n    return carry_on_bags, checked_bags\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_departure_info","title":"<code>extract_departure_info(flight_description)</code>","text":"<p>Extract departure airport, time, and date from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(airport, time, date) or (None, None, None)</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_departure_info(flight_description: str):\n    \"\"\"Extract departure airport, time, and date from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (airport, time, date) or (None, None, None)\n    \"\"\"\n    dep_pattern = (\n        r\"Leaves (.*?) at (\\d{1,2}:\\d{2}\\s?[AP]M) \"\n        r\"on ([A-Za-z]+, [A-Za-z]+ \\d{1,2})\"\n    )\n    if m := re.search(dep_pattern, flight_description):\n        return m.group(1).strip(), m.group(2).strip(), m.group(3).strip()\n    return None, None, None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_duration","title":"<code>extract_duration(flight_description)</code>","text":"<p>Extract flight duration from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(duration_minutes, duration_str) or (None, None)</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_duration(flight_description: str):\n    \"\"\"Extract flight duration from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (duration_minutes, duration_str) or (None, None)\n    \"\"\"\n    # Pattern with both hours and minutes\n    if m := re.search(r\"Total duration (\\d+) hr (\\d+) min\", flight_description):\n        hours = int(m.group(1))\n        minutes = int(m.group(2))\n        duration_minutes = hours * 60 + minutes\n        duration_str = f\"{hours} hr {minutes} min\"\n        return duration_minutes, duration_str\n\n    # Pattern with only hours (no minutes)\n    if m := re.search(r\"Total duration (\\d+) hr\", flight_description):\n        hours = int(m.group(1))\n        duration_minutes = hours * 60\n        duration_str = f\"{hours} hr\"\n        return duration_minutes, duration_str\n\n    # Pattern with only minutes (no hours)\n    if m := re.search(r\"Total duration (\\d+) min\", flight_description):\n        minutes = int(m.group(1))\n        duration_minutes = minutes\n        duration_str = f\"{minutes} hr\"\n        return duration_minutes, duration_str\n\n    return None, None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_final_price","title":"<code>extract_final_price(wait, driver, timeout)</code>","text":"<p>Extract the final price from the booking page.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>driver</code> <code>Chrome</code> <p>Selenium WebDriver instance</p> required <code>timeout</code> <code>int</code> <p>Timeout for waiting operations</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Final price in US dollars, or None if not found</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_final_price(wait: WebDriverWait, driver: Chrome, timeout: int):\n    \"\"\"Extract the final price from the booking page.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        driver (Chrome): Selenium WebDriver instance\n        timeout (int): Timeout for waiting operations\n\n    Returns:\n        int: Final price in US dollars, or None if not found\n    \"\"\"\n    # Wait for page to fully load\n    wait_until_class_stable(\n        driver,\n        (By.XPATH, \"//div[@role='progressbar']\"),\n        stable_duration=2.0,\n        timeout=timeout,\n    )\n\n    # Target the specific price element near \"Lowest total price\" text\n    price_xpath = (\n        \"//div[contains(text(), 'Lowest total price')]/preceding-sibling::div//span[@aria-label]\"\n    )\n\n    # Get aria-label with retry\n    aria_label = _extract_attribute_with_retry(wait, price_xpath, \"aria-label\")\n\n    # Check if aria_label is not None before regex\n    if aria_label and (m := re.search(r\"(\\d+(?:,\\d{3})*) US dollars\", aria_label)):\n        return int(m.group(1).replace(\",\", \"\"))\n\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_flight_details","title":"<code>extract_flight_details(flight_element)</code>","text":"<p>Extract all flight details from a flight element.</p> <p>Parameters:</p> Name Type Description Default <code>flight_element</code> <code>WebElement</code> <p>Selenium WebElement containing flight info</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(flight_info dict, price)</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_flight_details(flight_element: WebElement):\n    \"\"\"Extract all flight details from a flight element.\n\n    Args:\n        flight_element (WebElement): Selenium WebElement containing flight info\n\n    Returns:\n        tuple: (flight_info dict, price)\n    \"\"\"\n    # Initialize flight info structure\n    flight_info = create_empty_flight_info()\n\n    # Get flight description immediately and store as string\n    # Using relative XPath to search within the element\n    flight_description = flight_element.find_element(\n        By.XPATH,\n        \".//div[starts-with(@aria-label, 'From ')]\",\n    ).get_attribute(\"aria-label\")\n\n    if flight_description is None:\n        return flight_info\n    else:\n        # Clean the string\n        flight_description = flight_description.replace(\"\\u202f\", \" \").replace(\"\\xa0\", \" \")\n\n        # Extract all information using helper functions\n        flight_info[\"airline\"] = extract_airline(flight_description)\n\n        (\n            flight_info[\"departure_airport\"],\n            flight_info[\"departure_time\"],\n            flight_info[\"departure_date\"],\n        ) = extract_departure_info(flight_description)\n\n        flight_info[\"arrival_airport\"], flight_info[\"arrival_time\"], flight_info[\"arrival_date\"] = (\n            extract_arrival_info(flight_description)\n        )\n\n        flight_info[\"num_stops\"] = extract_num_stops(flight_description)\n\n        flight_info[\"connection_airports\"], flight_info[\"layover_durations\"] = extract_layover_info(\n            flight_description\n        )\n\n        flight_info[\"duration_minutes\"], flight_info[\"duration_str\"] = extract_duration(\n            flight_description\n        )\n\n        flight_info[\"carry_on_bags\"], flight_info[\"checked_bags\"] = extract_baggage_info(\n            flight_description\n        )\n\n    return flight_info\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_layover_info","title":"<code>extract_layover_info(flight_description)</code>","text":"<p>Extract connection airports and layover durations from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(connection_airports, layover_durations) as lists</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_layover_info(flight_description: str):\n    \"\"\"Extract connection airports and layover durations from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        tuple: (connection_airports, layover_durations) as lists\n    \"\"\"\n    # Pattern for \"layover at [airport name]\" - handles hours only, minutes only, or both\n    pattern_at = (\n        r\"Layover \\(\\d+ of \\d+\\) is a (\\d+\\s+(?:hr|min)(?:\\s+\\d+\\s+min)?)\"\n        r\"(?: overnight)? layover at ([^.]+?)(?:\\sin\\s[^.]+)?\\.(?:\\s|$)\"\n    )\n\n    # Pattern for \"layover in [city]\" - handles hours only, minutes only, or both\n    pattern_in = (\n        r\"Layover \\(\\d+ of \\d+\\) is a (\\d+\\s+(?:hr|min)(?:\\s+\\d+\\s+min)?)\"\n        r\"(?: overnight)? layover in ([^.]+?)\\.(?:\\s+Transfer)?\"\n    )\n\n    # Try pattern with \"at\" first\n    matches_at = re.findall(pattern_at, flight_description)\n    matches_in = re.findall(pattern_in, flight_description)\n\n    # pattern_at returns tuples of (duration, airport) due to 2 capturing groups\n    # pattern_in returns tuples of (duration, location)\n    all_matches = matches_at + matches_in\n    if all_matches:\n        layover_durations = [m[0].strip() for m in all_matches]\n        connection_airports = [m[1].strip() for m in all_matches]\n        return connection_airports, layover_durations\n    return [], []\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_num_stops","title":"<code>extract_num_stops(flight_description)</code>","text":"<p>Extract number of stops from flight description.</p> <p>Parameters:</p> Name Type Description Default <code>flight_description</code> <code>str</code> <p>Flight description text</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Number of stops or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_num_stops(flight_description: str):\n    \"\"\"Extract number of stops from flight description.\n\n    Args:\n        flight_description (str): Flight description text\n\n    Returns:\n        int: Number of stops or None\n    \"\"\"\n    if \"Nonstop\" in flight_description:\n        return 0\n    elif m := re.search(r\"(\\d+) stop\", flight_description):\n        return int(m.group(1))\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_price_classification_text","title":"<code>extract_price_classification_text(wait, driver, timeout)</code>","text":"<p>Find and extract the price classification text from the page.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>driver</code> <code>Chrome</code> <p>Selenium WebDriver instance</p> required <code>timeout</code> <code>int</code> <p>Timeout for waiting operations</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Text containing price classification, or None if not found</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_price_classification_text(wait: WebDriverWait, driver: Chrome, timeout: int):\n    \"\"\"Find and extract the price classification text from the page.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        driver (Chrome): Selenium WebDriver instance\n        timeout (int): Timeout for waiting operations\n\n    Returns:\n        str: Text containing price classification, or None if not found\n    \"\"\"\n    from .interactions import wait_until_class_stable\n\n    # Wait for page to load\n    wait_until_class_stable(\n        driver,\n        (By.XPATH, \"//div[@role='progressbar']\"),\n        stable_duration=2.0,\n        timeout=timeout,\n    )\n\n    # Look for div containing \"low\", \"high\", or \"typical\" in a span\n    price_xpath = (\n        \"(//h3[contains(text(), 'Price insights')]\"\n        \"/ancestor::div[contains(@class, 'VfPpkd-WsjYwc')]\"\n        \"//div[contains(., ' is ') and contains(., ' for ') and \"\n        \".//span[contains(text(), 'low') or \"\n        \"contains(text(), 'high') or \"\n        \"contains(text(), 'typical')]])[4]\"\n    )\n\n    return _extract_text_with_retry(wait, price_xpath)\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.extract_price_relativity","title":"<code>extract_price_relativity(wait, driver, timeout)</code>","text":"<p>Extract price relativity information from final page.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>WebDriverWait</code> <p>WebDriverWait instance</p> required <code>driver</code> <code>Chrome</code> <p>Selenium WebDriver instance</p> required <code>timeout</code> <code>int</code> <p>Timeout for waiting operations</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(classification, amount) where classification is one of    'typical', 'high', 'low', or None; amount is integer or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def extract_price_relativity(wait: WebDriverWait, driver: Chrome, timeout: int):\n    \"\"\"Extract price relativity information from final page.\n\n    Args:\n        wait (WebDriverWait): WebDriverWait instance\n        driver (Chrome): Selenium WebDriver instance\n        timeout (int): Timeout for waiting operations\n\n    Returns:\n        tuple: (classification, amount) where classification is one of\n               'typical', 'high', 'low', or None; amount is integer or None\n    \"\"\"\n    # Extract the text from the page\n    text = extract_price_classification_text(wait, driver, timeout)\n\n    if not text:\n        return None, None\n\n    # Parse classification and amount\n    classification = parse_price_classification(text)\n    amount = parse_price_difference(text)\n\n    return classification, amount\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.parse_price_classification","title":"<code>parse_price_classification(text)</code>","text":"<p>Parse classification from price relativity text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text containing price classification</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>'low', 'high', 'typical', or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def parse_price_classification(text: str):\n    \"\"\"Parse classification from price relativity text.\n\n    Args:\n        text (str): Text containing price classification\n\n    Returns:\n        str: 'low', 'high', 'typical', or None\n    \"\"\"\n    if not text:\n        return None\n\n    text_lower = text.lower()\n\n    if \"low\" in text_lower:\n        return \"low\"\n    elif \"high\" in text_lower:\n        return \"high\"\n    elif \"typical\" in text_lower:\n        return \"typical\"\n\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/parsers/#google_flights_scraper.parsers.parse_price_difference","title":"<code>parse_price_difference(text)</code>","text":"<p>Parse price difference amount from price relativity text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text containing price difference</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Amount saved (for 'cheaper'), 0 (for 'high'/'typical'), or None</p> Source code in <code>src/google_flights_scraper/parsers.py</code> <pre><code>def parse_price_difference(text: str):\n    \"\"\"Parse price difference amount from price relativity text.\n\n    Args:\n        text (str): Text containing price difference\n\n    Returns:\n        int: Amount saved (for 'cheaper'), 0 (for 'high'/'typical'), or None\n    \"\"\"\n    if not text:\n        return None\n\n    text_lower = text.lower()\n\n    if \"cheaper\" in text_lower:\n        # Extract dollar amount: \"$102 cheaper\" -&gt; 102\n        if m := re.search(r\"\\$(\\d+(?:,\\d{3})*)\\s+cheaper\", text):\n            return int(m.group(1).replace(\",\", \"\"))\n        return 0\n    elif \"low\" in text_lower or \"high\" in text_lower or \"typical\" in text_lower:\n        # For \"high\" or \"typical\", amount is 0\n        return 0\n\n    return None\n</code></pre>"},{"location":"reference/google_flights_scraper/scraper/","title":"scraper","text":"<p>Main scraper orchestration class.</p>"},{"location":"reference/google_flights_scraper/scraper/#google_flights_scraper.scraper.GoogleFlightsScraper","title":"<code>GoogleFlightsScraper</code>","text":"<p>Web scraper for Google Flights.</p> Source code in <code>src/google_flights_scraper/scraper.py</code> <pre><code>class GoogleFlightsScraper:\n    \"\"\"Web scraper for Google Flights.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the scraper with airport codes data.\"\"\"\n        package_dir = Path(__file__).parent.parent.parent\n        csv_path = package_dir / \"data\" / \"airport_codes.csv\"\n        self.airport_codes_df = pd.read_csv(csv_path)\n        self.driver = setup_chrome_driver(headless=True)\n        self.wait_time = DEFAULT_WAIT_TIME\n        self.wait = WebDriverWait(self.driver, self.wait_time)\n\n    def _create_result_structure(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n    ):\n        \"\"\"Create the initial result structure for storing flight data.\n\n        Args:\n            departure_code (str): IATA code or cirty for departure airport\n            departure_country (str): Country of departure airport or city\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country of arrival airport or city\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class string\n\n        Returns:\n            dict: Empty result structure\n        \"\"\"\n        return {\n            \"inputs\": {\n                \"departure_airport\": departure_code,\n                \"departure_country\": departure_country,\n                \"arrival_airport\": arrival_code,\n                \"arrival_country\": arrival_country,\n                \"departure_date\": start_date,\n                \"return_date\": end_date,\n                \"seat_class\": seat_class,\n            },\n            \"departure_flight\": create_empty_flight_info(),\n            \"return_flight\": create_empty_flight_info(),\n            \"price\": None,\n            \"price_classification\": None,\n            \"price_difference\": None,\n            \"price_relativity\": None,\n            \"status\": None,\n            \"url\": None,\n        }\n\n    def _validate_inputs(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        seat_class: str,\n        start_date: str,\n        end_date: str,\n        export_path: str | None,\n    ):\n        \"\"\"Validate all input parameters.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country for departure airport\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country for arrival airport\n            seat_class (str): Seat class string\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            export_path (str | None): Path to export, required if export is True\n\n        Returns:\n            bool: True if flight is domestic US\n        \"\"\"\n        # Validate airport codes\n        for code in [departure_code, arrival_code]:\n            validate_airport_code(code, self.airport_codes_df)\n\n        # Determine if domestic US flight\n        is_domestic_us = is_domestic_us_flight(\n            departure_country,\n            arrival_country,\n            self.airport_codes_df,\n        )\n\n        # Validate seat class\n        validate_seat_class(seat_class, is_domestic_us)\n\n        # Validate dates\n        validate_dates(start_date, end_date)\n\n        # Validate export params\n        validate_export_params(export_path)\n\n        return is_domestic_us\n\n    def _fill_search_form(\n        self,\n        departure_code: str,\n        arrival_code: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n        is_domestic_us: bool,\n    ):\n        \"\"\"Fill out the Google Flights search form.\n\n        Args:\n            departure_code (str): IATA code for departure airport\n            arrival_code (str): IATA code for arrival airport\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class string\n            is_domestic_us (bool): Whether flight is domestic US\n        \"\"\"\n        # Enter airports\n        enter_airports(self.wait, departure_code, arrival_code)\n\n        # Enter dates\n        enter_dates(self.wait, start_date, end_date)\n\n        # Select seat class\n        select_seat_class(self.wait, seat_class, is_domestic_us)\n\n        # Click search button\n        press_search_button(self.wait)\n\n    def _find_flight_with_retry(\n        self,\n        result: dict,\n        key: str,\n        max_retries: int = 3,\n        sleep_s: float = 0.5,\n    ):\n        \"\"\"Find best flight element with retry and extract details.\n\n        Args:\n            result (dict): Dictionary to populate with flight details\n            key (str): Dict key to add data to (departure or return flight)\n            max_retries (int): Number of times to retry selecting element\n            sleep_s (float): How long to sleep (seconds) in between each try\n\n        Returns:\n            WebElement | None\n        \"\"\"\n        for attempt in range(max_retries):\n            try:\n                flight = find_and_select_best_flight(\n                    self.wait,\n                    self.driver,\n                    self.wait_time,\n                )\n\n                if flight is None:\n                    return None, f\"No {key} found.\"\n\n                result[key] = extract_flight_details(flight)\n                flight.click()\n                return None\n\n            except StaleElementReferenceException:\n                if attempt == max_retries - 1:\n                    return f\"No {key} found.\"\n                time.sleep(sleep_s)\n\n    def _select_best_flights(self, result: dict):\n        \"\"\"Select the best departure and return flights and extract details.\n\n        Args:\n            result (dict): Dictionary to populate with flight details\n\n        Returns:\n            tuple: (updated result dictionary, success status message)\n        \"\"\"\n        # Select Departure\n        err = self._find_flight_with_retry(\n            result,\n            key=\"departure_flight\",\n        )\n        if err:\n            return result, err\n\n        # Select Return\n        err = self._find_flight_with_retry(\n            result,\n            key=\"return_flight\",\n        )\n        if err:\n            return result, err\n\n        # Extract price from final booking page\n        result[\"price\"] = extract_final_price(self.wait, self.driver, self.wait_time)\n\n        # Capture the final page URL\n        result[\"url\"] = self.driver.current_url\n\n        return result, \"Ran successfully.\"\n\n    def _calc_price_rel(self, price: int, price_difference: int | None):\n        \"\"\"Calculate price relaticity (% discount).\n\n        Args:\n            price (int): Final flight price\n            price_difference (int | None): If found, how much cheaper flight is than usual\n\n        Returns:\n            float: Percentage discount\n        \"\"\"\n        if price_difference is not None:\n            return round(float(price_difference / (price + price_difference)), 4)\n        else:\n            return None\n\n    def _export_data(self, result: dict, export_path: str):\n        \"\"\"Export dict to file based on extension.\n\n        Args:\n            result (dict): Resulting dictionary after scraping\n            export_path (str): Path to export file to\n        \"\"\"\n        if export_path.endswith(\".json\"):\n            json_output = json.dumps(result, indent=2)\n            with open(export_path, \"w\") as f:\n                f.write(json_output)\n        elif export_path.endswith(\".csv\"):\n            df = pd.json_normalize(result, sep=\"_\")\n            df.to_csv(export_path, index=False)\n\n    def scrape_flight(\n        self,\n        departure_code: str,\n        departure_country: str,\n        arrival_code: str,\n        arrival_country: str,\n        start_date: str,\n        end_date: str,\n        seat_class: str,\n        export_path: str | None = None,\n    ):\n        \"\"\"Scrape Google Flights for specified route and parameters.\n\n        Args:\n            departure_code (str): IATA code or city for departure airport\n            departure_country (str): Country for departure airport\n            arrival_code (str): IATA code or city for arrival airport\n            arrival_country (str): Country for arrival airport\n            start_date (str): Departure date in MM/DD/YYYY format\n            end_date (str): Return date in MM/DD/YYYY format\n            seat_class (str): Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)\n            export_path (str | None): Path to export, required if export is True\n\n        Returns:\n            dict: Complete flight information as dictionary\n        \"\"\"\n        # Initialize result structure\n        result = self._create_result_structure(\n            departure_code,\n            departure_country,\n            arrival_code,\n            arrival_country,\n            start_date,\n            end_date,\n            seat_class,\n        )\n\n        try:\n            # Validate inputs\n            is_domestic_us = self._validate_inputs(\n                departure_code,\n                departure_country,\n                arrival_code,\n                arrival_country,\n                seat_class,\n                start_date,\n                end_date,\n                export_path,\n            )\n\n            # Navigate to Google Flights\n            self.driver.get(\"https://www.google.com/travel/flights\")\n\n            # Fill search form\n            self._fill_search_form(\n                departure_code,\n                arrival_code,\n                start_date,\n                end_date,\n                seat_class,\n                is_domestic_us,\n            )\n\n            # Select best flights and extract details\n            result, status = self._select_best_flights(result)\n\n            # Extract price difference\n            if status == \"Ran successfully.\":\n                (result[\"price_classification\"], result[\"price_difference\"]) = (\n                    extract_price_relativity(self.wait, self.driver, self.wait_time)\n                )\n\n            # Calculate price relativity\n            result[\"price_relativity\"] = self._calc_price_rel(\n                result[\"price\"], result[\"price_difference\"]\n            )\n\n        except Exception as e:\n            print(f\"Error scraping flight: {e}\")\n            status = f\"Error: {str(e)}\"\n        finally:\n            # Close the driver\n            self.driver.quit()\n            time.sleep(1)\n\n        # Update status\n        result[\"status\"] = status\n\n        # Export\n        if export_path:\n            self._export_data(result, export_path)\n\n        return result\n</code></pre>"},{"location":"reference/google_flights_scraper/scraper/#google_flights_scraper.scraper.GoogleFlightsScraper.scrape_flight","title":"<code>scrape_flight(departure_code, departure_country, arrival_code, arrival_country, start_date, end_date, seat_class, export_path=None)</code>","text":"<p>Scrape Google Flights for specified route and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>departure_code</code> <code>str</code> <p>IATA code or city for departure airport</p> required <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_code</code> <code>str</code> <p>IATA code or city for arrival airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <code>seat_class</code> <code>str</code> <p>Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)</p> required <code>export_path</code> <code>str | None</code> <p>Path to export, required if export is True</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Complete flight information as dictionary</p> Source code in <code>src/google_flights_scraper/scraper.py</code> <pre><code>def scrape_flight(\n    self,\n    departure_code: str,\n    departure_country: str,\n    arrival_code: str,\n    arrival_country: str,\n    start_date: str,\n    end_date: str,\n    seat_class: str,\n    export_path: str | None = None,\n):\n    \"\"\"Scrape Google Flights for specified route and parameters.\n\n    Args:\n        departure_code (str): IATA code or city for departure airport\n        departure_country (str): Country for departure airport\n        arrival_code (str): IATA code or city for arrival airport\n        arrival_country (str): Country for arrival airport\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n        seat_class (str): Seat class (e.g., \"Economy (include Basic)\", \"Business\", etc.)\n        export_path (str | None): Path to export, required if export is True\n\n    Returns:\n        dict: Complete flight information as dictionary\n    \"\"\"\n    # Initialize result structure\n    result = self._create_result_structure(\n        departure_code,\n        departure_country,\n        arrival_code,\n        arrival_country,\n        start_date,\n        end_date,\n        seat_class,\n    )\n\n    try:\n        # Validate inputs\n        is_domestic_us = self._validate_inputs(\n            departure_code,\n            departure_country,\n            arrival_code,\n            arrival_country,\n            seat_class,\n            start_date,\n            end_date,\n            export_path,\n        )\n\n        # Navigate to Google Flights\n        self.driver.get(\"https://www.google.com/travel/flights\")\n\n        # Fill search form\n        self._fill_search_form(\n            departure_code,\n            arrival_code,\n            start_date,\n            end_date,\n            seat_class,\n            is_domestic_us,\n        )\n\n        # Select best flights and extract details\n        result, status = self._select_best_flights(result)\n\n        # Extract price difference\n        if status == \"Ran successfully.\":\n            (result[\"price_classification\"], result[\"price_difference\"]) = (\n                extract_price_relativity(self.wait, self.driver, self.wait_time)\n            )\n\n        # Calculate price relativity\n        result[\"price_relativity\"] = self._calc_price_rel(\n            result[\"price\"], result[\"price_difference\"]\n        )\n\n    except Exception as e:\n        print(f\"Error scraping flight: {e}\")\n        status = f\"Error: {str(e)}\"\n    finally:\n        # Close the driver\n        self.driver.quit()\n        time.sleep(1)\n\n    # Update status\n    result[\"status\"] = status\n\n    # Export\n    if export_path:\n        self._export_data(result, export_path)\n\n    return result\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/","title":"validators","text":"<p>Validation functions for Google Flights scraper.</p>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.is_domestic_us_flight","title":"<code>is_domestic_us_flight(departure_country, arrival_country, airport_codes_df)</code>","text":"<p>Determine if flight is domestic US based on airport codes and cities.</p> <p>Parameters:</p> Name Type Description Default <code>departure_country</code> <code>str</code> <p>Country for departure airport</p> required <code>arrival_country</code> <code>str</code> <p>Country for arrival airport</p> required <code>airport_codes_df</code> <code>DataFrame</code> <p>DataFrame containing airport codes</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if both airports are in United States of America</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def is_domestic_us_flight(\n    departure_country: str, arrival_country: str, airport_codes_df: DataFrame\n):\n    \"\"\"Determine if flight is domestic US based on airport codes and cities.\n\n    Args:\n        departure_country (str): Country for departure airport\n        arrival_country (str): Country for arrival airport\n        airport_codes_df (DataFrame): DataFrame containing airport codes\n\n    Returns:\n        bool: True if both airports are in United States of America\n    \"\"\"\n    usa = \"United States of America\"\n    if (departure_country.upper() == usa.upper()) and (arrival_country.upper() == usa.upper()):\n        return True\n    return False\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.validate_airport_code","title":"<code>validate_airport_code(airport_code, airport_codes_df)</code>","text":"<p>Validate if airport code or city exists in dataset.</p> <p>Parameters:</p> Name Type Description Default <code>airport_code</code> <code>str</code> <p>IATA code or City to validate</p> required <code>airport_codes_df</code> <code>DataFrame</code> <p>DataFrame containing airport codes and cities</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If airport code or city is not found in dataset</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def validate_airport_code(airport_code: str, airport_codes_df: DataFrame):\n    \"\"\"Validate if airport code or city exists in dataset.\n\n    Args:\n        airport_code (str): IATA code or City to validate\n        airport_codes_df (DataFrame): DataFrame containing airport codes and cities\n\n    Raises:\n        ValueError: If airport code or city is not found in dataset\n    \"\"\"\n    # IATA Code\n    if not airport_codes_df[\"IATA\"].str.upper().isin([airport_code.upper()]).any():\n        # Cities\n        if not airport_codes_df[\"City\"].str.upper().isin([airport_code.upper()]).any():\n            raise ValueError(f\"Invalid airport input: {airport_code}\")\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.validate_dates","title":"<code>validate_dates(start_date, end_date)</code>","text":"<p>Validate that end_date is after start_date.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>Departure date in MM/DD/YYYY format</p> required <code>end_date</code> <code>str</code> <p>Return date in MM/DD/YYYY format</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If dates are invalid or end_date is before start_date</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def validate_dates(start_date: str, end_date: str):\n    \"\"\"Validate that end_date is after start_date.\n\n    Args:\n        start_date (str): Departure date in MM/DD/YYYY format\n        end_date (str): Return date in MM/DD/YYYY format\n\n    Raises:\n        ValueError: If dates are invalid or end_date is before start_date\n    \"\"\"\n    try:\n        start = datetime.strptime(start_date, \"%m/%d/%Y\")\n        end = datetime.strptime(end_date, \"%m/%d/%Y\")\n    except ValueError as e:\n        raise ValueError(\"Invalid date format. Expected MM/DD/YYYY:\") from e\n\n    if end &lt;= start:\n        raise ValueError(f\"Return date ({end_date}) must be after departure date ({start_date})\")\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.validate_export_params","title":"<code>validate_export_params(export_path=None)</code>","text":"<p>Validate export parameters.</p> <p>Parameters:</p> Name Type Description Default <code>export_path</code> <code>str | None</code> <p>Path to export file</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If export_path has invalid extension</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def validate_export_params(export_path: str | None = None):\n    \"\"\"Validate export parameters.\n\n    Args:\n        export_path (str | None): Path to export file\n\n    Raises:\n        ValueError: If export_path has invalid extension\n    \"\"\"\n    if export_path:\n        # Check file extension\n        if not (export_path.endswith(\".json\") or export_path.endswith(\".csv\")):\n            raise ValueError(f\"Export path must end with .json or .csv, got: {export_path}\")\n</code></pre>"},{"location":"reference/google_flights_scraper/validators/#google_flights_scraper.validators.validate_seat_class","title":"<code>validate_seat_class(seat_class, is_domestic_us)</code>","text":"<p>Validate seat class selection based on flight type.</p> <p>Parameters:</p> Name Type Description Default <code>seat_class</code> <code>str</code> <p>Seat class string</p> required <code>is_domestic_us</code> <code>bool</code> <p>Whether flight is domestic US</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If seat class is invalid for the flight type</p> Source code in <code>src/google_flights_scraper/validators.py</code> <pre><code>def validate_seat_class(seat_class: str, is_domestic_us: bool):\n    \"\"\"Validate seat class selection based on flight type.\n\n    Args:\n        seat_class (str): Seat class string\n        is_domestic_us (bool): Whether flight is domestic US\n\n    Raises:\n        ValueError: If seat class is invalid for the flight type\n    \"\"\"\n    # Validate based on flight type\n    if is_domestic_us:\n        if seat_class.lower() not in VALID_CLASSES_DOMESTIC_US:\n            raise ValueError(f\"Invalid seat class for domestic US flight: {seat_class}\")\n    else:\n        if seat_class.lower() not in VALID_CLASSES_INTERNATIONAL:\n            raise ValueError(f\"Invalid seat class for international flight: {seat_class}\")\n</code></pre>"},{"location":"tutorial/batch_request/","title":"Tutorial: Batch Flight Requests","text":"In\u00a0[1]: Copied! <pre># Import\nfrom datetime import datetime, timedelta\n\nfrom google_flights_scraper.batch_scraper import (\n    scrape_date_range,\n    scrape_multiple_destinations,\n)\n\n# Get today's date\ntoday = datetime.today()\n</pre> # Import from datetime import datetime, timedelta  from google_flights_scraper.batch_scraper import (     scrape_date_range,     scrape_multiple_destinations, )  # Get today's date today = datetime.today() <p>Below are the possible parameters when making a request:</p> <p>Required Inputs</p> <p><code>departure_code</code> : Departure airport or city (a single location) <code>departure_country</code> Departure country (a single country) <code>arrival_codes</code> : A list of possible destination airports or cities <code>arrival_countries</code> : The matching list of possible destination countries <code>start_date</code> : Departure date (in <code>\"MM/DD/YYY\"</code> format) <code>end_date</code> : Arrrival date  (in <code>\"MM/DD/YYY\"</code> format) <code>seat_classes</code> : The matching list of seat classes (reason this is <code>list</code> and not <code>str</code> is because domestic and international flights can have different class names)</p> <p>Optional Inputs</p> <p><code>output_path</code> : path to output <code>.csv</code>  (ex: <code>export.csv</code>) <code>delay_seconds</code>: How many seconds to delay between requests. Can be helpful to increase if you are being rate limited by Google.</p> In\u00a0[2]: Copied! <pre># Search Mapping\ncity_search = {\n    \"SEA\": {\"country\": \"United States of America\", \"seat_class\": \"Economy (exclude Basic)\"},\n    \"London\": {\"country\": \"United Kingdom\", \"seat_class\": \"Economy\"},\n    \"Paris\": {\"country\": \"France\", \"seat_class\": \"Economy\"},\n    \"SFO\": {\"country\": \"United States of America\", \"seat_class\": \"Economy (exclude Basic)\"},\n}\n\n# Individual Lists\ndestination_codes = list(city_search.keys())\ndestination_countries = [city_search[code][\"country\"] for code in destination_codes]\nseat_classes = [city_search[code][\"seat_class\"] for code in destination_codes]\n\n# Create Dates\nstart = (today + timedelta(weeks=8)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=10)).strftime(\"%m/%d/%Y\")\n\n# Run\ndf_destinations = scrape_multiple_destinations(\n    departure_code=\"New York\",\n    departure_country=\"United States of America\",\n    arrival_codes=destination_codes,\n    arrival_countries=destination_countries,\n    start_date=start,\n    end_date=end,\n    seat_classes=seat_classes,\n    delay_seconds=3.0,\n)\n</pre> # Search Mapping city_search = {     \"SEA\": {\"country\": \"United States of America\", \"seat_class\": \"Economy (exclude Basic)\"},     \"London\": {\"country\": \"United Kingdom\", \"seat_class\": \"Economy\"},     \"Paris\": {\"country\": \"France\", \"seat_class\": \"Economy\"},     \"SFO\": {\"country\": \"United States of America\", \"seat_class\": \"Economy (exclude Basic)\"}, }  # Individual Lists destination_codes = list(city_search.keys()) destination_countries = [city_search[code][\"country\"] for code in destination_codes] seat_classes = [city_search[code][\"seat_class\"] for code in destination_codes]  # Create Dates start = (today + timedelta(weeks=8)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=10)).strftime(\"%m/%d/%Y\")  # Run df_destinations = scrape_multiple_destinations(     departure_code=\"New York\",     departure_country=\"United States of America\",     arrival_codes=destination_codes,     arrival_countries=destination_countries,     start_date=start,     end_date=end,     seat_classes=seat_classes,     delay_seconds=3.0, ) <pre>[1/4] Searching New York \u2192 SEA (Economy (exclude Basic))...\n[2/4] Searching New York \u2192 London (Economy)...\n[3/4] Searching New York \u2192 Paris (Economy)...\n[4/4] Searching New York \u2192 SFO (Economy (exclude Basic))...\nTotal searches: 4, Successful: 4\n</pre> In\u00a0[5]: Copied! <pre>df_destinations\n</pre> df_destinations Out[5]: departure_airport departure_country arrival_airport arrival_country departure_date return_date seat_class departure_airline departure_departure_airport departure_departure_date ... return_duration_minutes return_duration_str return_carry_on_bags return_checked_bags price price_classification price_difference price_relativity status url 3 New York United States of America SFO United States of America 04/03/2026 04/17/2026 Economy (exclude Basic) JetBlue John F. Kennedy International Airport Friday, April 3 ... 344 5 hr 44 min 1.0 0.0 418 low 525 0.5567 Ran successfully. https://www.google.com/travel/flights/booking?... 0 New York United States of America SEA United States of America 04/03/2026 04/17/2026 Economy (exclude Basic) Alaska John F. Kennedy International Airport Friday, April 3 ... 321 5 hr 21 min 1.0 0.0 375 low 427 0.5324 Ran successfully. https://www.google.com/travel/flights/booking?... 2 New York United States of America Paris France 04/03/2026 04/17/2026 Economy American John F. Kennedy International Airport Friday, April 3 ... 730 12 hr 10 min NaN NaN 566 low 220 0.2799 Ran successfully. https://www.google.com/travel/flights/booking?... 1 New York United States of America London United Kingdom 04/03/2026 04/17/2026 Economy Norse Atlantic UK John F. Kennedy International Airport Friday, April 3 ... 470 7 hr 50 min NaN NaN 532 typical 0 0.0000 Ran successfully. https://www.google.com/travel/flights/booking?... <p>4 rows \u00d7 41 columns</p> <p>This returns a pandas DataFrame of the best flight for each destination, sorted in order of <code>price_relativity</code> highlight the flights which are the \"best deal\".</p> <p>This also contains all the other information returned by the basic flight request function.</p> <p>Here are the possible parameters for this request:</p> <p>Required Inputs</p> <p><code>departure_code</code> : Departure airport or city (a single location) <code>departure_country</code> : Departure country (a single country) <code>arrival_code</code> : Arrival airport or city (a single location) <code>arrival_country</code> : Arrival country (a single country) <code>start_date_range</code> : Start date for search (in <code>\"MM/DD/YYY\"</code> format) <code>end_date_range</code> : End date for search (in <code>\"MM/DD/YYY\"</code> format) <code>min_trip_length</code> : Minimum trip length (in days) <code>max_trip_length</code> : Maximum trip length (in days) <code>seat_class</code> : Class of seat (a single selection)</p> <p>Optional Inputs</p> <p><code>output_path</code> : path to output <code>.csv</code>  (ex: <code>export.csv</code>) <code>delay_seconds</code>: How many seconds to delay between requests. Can be helpful to increase if you are being rate limited by Google.</p> In\u00a0[3]: Copied! <pre># Create Dates\nstart = (today + timedelta(weeks=11)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=12)).strftime(\"%m/%d/%Y\")\n\n# Run\ndf_dates = scrape_date_range(\n    departure_code=\"JFK\",\n    departure_country=\"United States of America\",\n    arrival_code=\"London\",\n    arrival_country=\"United Kingdom\",\n    start_date_range=start,\n    end_date_range=end,\n    min_trip_length=5,\n    max_trip_length=7,\n    seat_class=\"Economy\",\n    delay_seconds=3.0,\n)\n</pre> # Create Dates start = (today + timedelta(weeks=11)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=12)).strftime(\"%m/%d/%Y\")  # Run df_dates = scrape_date_range(     departure_code=\"JFK\",     departure_country=\"United States of America\",     arrival_code=\"London\",     arrival_country=\"United Kingdom\",     start_date_range=start,     end_date_range=end,     min_trip_length=5,     max_trip_length=7,     seat_class=\"Economy\",     delay_seconds=3.0, ) <pre>[1/6] Searching 04/24/2026 \u2192 04/29/2026...\n[2/6] Searching 04/24/2026 \u2192 04/30/2026...\n[3/6] Searching 04/24/2026 \u2192 05/01/2026...\n[4/6] Searching 04/25/2026 \u2192 04/30/2026...\n[5/6] Searching 04/25/2026 \u2192 05/01/2026...\n[6/6] Searching 04/26/2026 \u2192 05/01/2026...\nTotal searches: 6, Successful: 6\n</pre> In\u00a0[4]: Copied! <pre>df_dates\n</pre> df_dates Out[4]: departure_airport departure_country arrival_airport arrival_country departure_date return_date seat_class departure_airline departure_departure_airport departure_departure_date ... return_duration_str return_carry_on_bags return_checked_bags price price_classification price_difference price_relativity status url trip_length_days 5 JFK United States of America London United Kingdom 04/26/2026 05/01/2026 Economy British Airways John F. Kennedy International Airport Sunday, April 26 ... 7 hr 50 min None None 544 low 382 0.4125 Ran successfully. https://www.google.com/travel/flights/booking?... 5 4 JFK United States of America London United Kingdom 04/25/2026 05/01/2026 Economy Norse Atlantic UK John F. Kennedy International Airport Saturday, April 25 ... 7 hr 50 min None None 370 low 196 0.3463 Ran successfully. https://www.google.com/travel/flights/booking?... 6 2 JFK United States of America London United Kingdom 04/24/2026 05/01/2026 Economy Norse Atlantic UK John F. Kennedy International Airport Friday, April 24 ... 7 hr 50 min None None 414 low 152 0.2686 Ran successfully. https://www.google.com/travel/flights/booking?... 7 3 JFK United States of America London United Kingdom 04/25/2026 04/30/2026 Economy Norse Atlantic UK John F. Kennedy International Airport Saturday, April 25 ... 7 hr 50 min None None 413 low 138 0.2505 Ran successfully. https://www.google.com/travel/flights/booking?... 5 0 JFK United States of America London United Kingdom 04/24/2026 04/29/2026 Economy American John F. Kennedy International Airport Friday, April 24 ... 7 hr 50 min None None 544 low 148 0.2139 Ran successfully. https://www.google.com/travel/flights/booking?... 5 1 JFK United States of America London United Kingdom 04/24/2026 04/30/2026 Economy Norse Atlantic UK John F. Kennedy International Airport Friday, April 24 ... 7 hr 50 min None None 457 typical 0 0.0000 Ran successfully. https://www.google.com/travel/flights/booking?... 6 <p>6 rows \u00d7 42 columns</p> <p>This also returns a pandas DataFrame of the best flight for each destination, sorted in order of <code>price_relativity</code> highlight the flights which are the \"best deal\".</p> <p>This also contains all the other information returned by the basic flight request function.</p>"},{"location":"tutorial/batch_request/#tutorial-batch-flight-requests","title":"Tutorial: Batch Flight Requests\u00b6","text":"<p>The <code>google_flights_scraper</code> package can also be used to make batch request of multiple flights where a certain criteria is varied (e.g. destination or dates)</p>"},{"location":"tutorial/batch_request/#set-up","title":"Set Up\u00b6","text":""},{"location":"tutorial/batch_request/#destination-search","title":"Destination Search\u00b6","text":"<p>Search multiple destinations on certain dates. Helpful if you know when you want to travel, but don't know where and are looking for good deals.</p>"},{"location":"tutorial/batch_request/#example-departing-from-new-york","title":"Example: Departing from New York\u00b6","text":"<p>In this example, we are departing from New York and searching for flights to SEA, London, Paris, and SFO.</p>"},{"location":"tutorial/batch_request/#date-range-search","title":"Date Range Search\u00b6","text":"<p>Search all date combinations for a specific route between certain dates. Helpful if you're flexible on timing and looking for finding cheaper days to fly.</p>"},{"location":"tutorial/batch_request/#example-jfk-to-london","title":"Example: JFK to London\u00b6","text":"<p>In this example, we are departing from JFK and arriving in London anytime within a two-week period, searching from trip from 5-7 days long.</p>"},{"location":"tutorial/simple_request/","title":"Tutorial: Simple Flight Request","text":"In\u00a0[1]: Copied! <pre># Auto-reload modules\n%load_ext autoreload\n%autoreload 2\n</pre> # Auto-reload modules %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># Import\nfrom datetime import datetime, timedelta\n\nfrom google_flights_scraper import GoogleFlightsScraper\n\n# Get today's date\ntoday = datetime.today()\n</pre> # Import from datetime import datetime, timedelta  from google_flights_scraper import GoogleFlightsScraper  # Get today's date today = datetime.today() <p>Below are the possible parameters when making a request:</p> <p>Required Inputs</p> <p><code>departure_code</code> : Departure airport, can be airport code or city name <code>departure_country</code> : Departure country, see <code>data/airport_codes.csv</code> for naming <code>arrival_code</code> : Arrival airport, can be airport code or city name <code>arrival_country</code> : Departure country, see <code>data/airport_codes.csv</code> for naming <code>start_date</code> : Departure date, in <code>\"MM/DD/YYYY\"</code> format <code>end_date</code> : Return date, in <code>\"MM/DD/YYYY\"</code> format <code>seat_class</code> : Class of seat to search for. Options are:</p> <ul> <li>Domestic (US):<ul> <li>Economy (include Basic)</li> <li>Economy (exclude Basic)</li> <li>Premium economy</li> <li>Business</li> <li>First</li> </ul> </li> <li>International:<ul> <li>Economy</li> <li>Premium economy</li> <li>Business</li> <li>First</li> </ul> </li> </ul> <p>Optional Inputs</p> <p><code>export_path</code> : Path and file type export to (ex: <code>export.json</code> or <code>export.csv</code>)</p> <p>This will return the following info as a <code>dict</code>:</p> <pre>{\n\"inputs\": {\n    \"departure_airport\",\n    \"departure_country\"\n    \"arrival_airport\",\n    \"arrival_country\",\n    \"departure_date\",\n    \"return_date\",\n    \"seat_class\"\n},\n\"departure_flight\": {\n    \"airline\",\n    \"departure_airport\",\n    \"departure_date\",\n    \"departure_time\",\n    \"num_stops\",\n    \"connection_airports\",\n    \"layover_durations\",\n    \"arrival_airport\",\n    \"arrival_date\",\n    \"arrival_time\"\n    \"duration_minutes\", # Total duration of travel (in minutes)\n    \"duration_str\", # Duration formatted as readability (X hr X min)\n    \"carry_on_bags\", # Sometimes None, this information doesn't always populate in Google Flights\n    \"checked_bags\" # Sometimes None, this information doesn't always populate in Google Flights\n},\n\"return_flight\": {\n    \"airline\",\n    \"departure_airport\",\n    \"departure_date\",\n    \"departure_time\",\n    \"num_stops\",\n    \"connection_airports\",\n    \"layover_durations\",\n    \"arrival_airport\",\n    \"arrival_date\",\n    \"arrival_time\"\n    \"duration_minutes\", # Total duration of travel (in minutes)\n    \"duration_str\", # Duration formatted as readability (X hr X min)\n    \"carry_on_bags\", # Sometimes None, this information doesn't always populate in Google Flights\n    \"checked_bags\" # Sometimes None, this information doesn't always populate in Google Flights\n},\n\"price\",\n\"price_classification\", # One of low, typical, or high. Sometimes null if Google Flights does not provide this info for a specific flight.\n\"price_difference\", # If price_classificaiton is low, how much cheaper this flight is than usual ($).\n\"price_relativity\": # If price_classificaiton is low, how much cheaper this flight is than usual (% off).\n\"status\" # If the scraper ran successfully, or if not, what the error was.\n\"url\" # URL of final page\n}\n</pre> In\u00a0[3]: Copied! <pre># Initialize\nscraper = GoogleFlightsScraper()\n\n# Create Dates\nstart = (today + timedelta(weeks=4)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=5)).strftime(\"%m/%d/%Y\")\n\n# Run\nresult = scraper.scrape_flight(\n    departure_code=\"LAX\",\n    departure_country=\"United States of America\",\n    arrival_code=\"New York\",\n    arrival_country=\"United States of America\",\n    start_date=start,\n    end_date=end,\n    seat_class=\"Economy (include Basic)\",\n)\n</pre> # Initialize scraper = GoogleFlightsScraper()  # Create Dates start = (today + timedelta(weeks=4)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=5)).strftime(\"%m/%d/%Y\")  # Run result = scraper.scrape_flight(     departure_code=\"LAX\",     departure_country=\"United States of America\",     arrival_code=\"New York\",     arrival_country=\"United States of America\",     start_date=start,     end_date=end,     seat_class=\"Economy (include Basic)\", ) In\u00a0[4]: Copied! <pre>result\n</pre> result Out[4]: <pre>{'inputs': {'departure_airport': 'LAX',\n  'departure_country': 'United States of America',\n  'arrival_airport': 'New York',\n  'arrival_country': 'United States of America',\n  'departure_date': '03/06/2026',\n  'return_date': '03/13/2026',\n  'seat_class': 'Economy (include Basic)'},\n 'departure_flight': {'airline': 'Spirit',\n  'departure_airport': 'Los Angeles International Airport',\n  'departure_date': 'Friday, March 6',\n  'departure_time': '8:20 AM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'Newark Liberty International Airport',\n  'arrival_date': 'Friday, March 6',\n  'arrival_time': '4:35 PM',\n  'duration_minutes': 315,\n  'duration_str': '5 hr 15 min',\n  'carry_on_bags': 0,\n  'checked_bags': 0},\n 'return_flight': {'airline': 'Spirit',\n  'departure_airport': 'Newark Liberty International Airport',\n  'departure_date': 'Friday, March 13',\n  'departure_time': '6:59 PM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'Los Angeles International Airport',\n  'arrival_date': 'Friday, March 13',\n  'arrival_time': '10:14 PM',\n  'duration_minutes': 375,\n  'duration_str': '6 hr 15 min',\n  'carry_on_bags': 0,\n  'checked_bags': 0},\n 'price': 189,\n 'price_classification': 'low',\n 'price_difference': 87,\n 'price_relativity': 0.3152,\n 'status': 'Ran successfully.',\n 'url': 'https://www.google.com/travel/flights/booking?tfs=CBwQAhpGEgoyMDI2LTAzLTA2IiAKA0xBWBIKMjAyNi0wMy0wNhoDRVdSKgJOSzIEMTY5M2oHCAESA0xBWHINCAMSCS9tLzAyXzI4NhpGEgoyMDI2LTAzLTEzIiAKA0VXUhIKMjAyNi0wMy0xMxoDTEFYKgJOSzIEMTY3MGoNCAMSCS9tLzAyXzI4NnIHCAESA0xBWEABSAFwAYIBCwj___________8BmAEB&amp;tfu=CmxDalJJZFd0Q2R6ZHFNMUJRTlVGQlJHVnRiMmRDUnkwdExTMHRMUzB0TFhaM2VXMHhNRUZCUVVGQlIyMUhTMnRyVFU1bk5rTkJFZ1pPU3pFMk56QWFDd2lDa3dFUUFob0RWVk5FT0J4d2dwTUISAggAIgMKATE'}</pre> <p>This returns a Nonstop flight on Spirit landing at Newark Liberty International Airport. Google Flights tends to prioritize the cheapest flight as the \"best\" flight, but sometimes will choose more expensive flights if they offer significantly better travel (usually less layover time).</p> <p>This price is classified as <code>\"low\"</code> and <code>\"price_difference\"</code> of $87 is returned (<code>\"price_relativity\"</code> = 31.52% discount).</p> In\u00a0[5]: Copied! <pre># Initialize\nscraper = GoogleFlightsScraper()\n\n# Create Dates\nstart = (today + timedelta(weeks=8)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=10)).strftime(\"%m/%d/%Y\")\n\n# Run\nresult = scraper.scrape_flight(\n    departure_code=\"New York\",\n    departure_country=\"United States of America\",\n    arrival_code=\"Tokyo\",\n    arrival_country=\"Japan\",\n    start_date=start,\n    end_date=end,\n    seat_class=\"Premium economy\",\n)\nresult\n</pre> # Initialize scraper = GoogleFlightsScraper()  # Create Dates start = (today + timedelta(weeks=8)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=10)).strftime(\"%m/%d/%Y\")  # Run result = scraper.scrape_flight(     departure_code=\"New York\",     departure_country=\"United States of America\",     arrival_code=\"Tokyo\",     arrival_country=\"Japan\",     start_date=start,     end_date=end,     seat_class=\"Premium economy\", ) result Out[5]: <pre>{'inputs': {'departure_airport': 'New York',\n  'departure_country': 'United States of America',\n  'arrival_airport': 'Tokyo',\n  'arrival_country': 'Japan',\n  'departure_date': '04/03/2026',\n  'return_date': '04/17/2026',\n  'seat_class': 'Premium economy'},\n 'departure_flight': {'airline': 'United',\n  'departure_airport': 'Newark Liberty International Airport',\n  'departure_date': 'Friday, April 3',\n  'departure_time': '11:25 AM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'Narita International Airport',\n  'arrival_date': 'Saturday, April 4',\n  'arrival_time': '2:30 PM',\n  'duration_minutes': 845,\n  'duration_str': '14 hr 5 min',\n  'carry_on_bags': None,\n  'checked_bags': None},\n 'return_flight': {'airline': 'United',\n  'departure_airport': 'Narita International Airport',\n  'departure_date': 'Friday, April 17',\n  'departure_time': '5:25 PM',\n  'num_stops': 0,\n  'connection_airports': [],\n  'layover_durations': [],\n  'arrival_airport': 'Newark Liberty International Airport',\n  'arrival_date': 'Friday, April 17',\n  'arrival_time': '5:10 PM',\n  'duration_minutes': 765,\n  'duration_str': '12 hr 45 min',\n  'carry_on_bags': None,\n  'checked_bags': None},\n 'price': 3393,\n 'price_classification': None,\n 'price_difference': None,\n 'price_relativity': None,\n 'status': 'Ran successfully.',\n 'url': 'https://www.google.com/travel/flights/booking?tfs=CBwQAhpJEgoyMDI2LTA0LTAzIh4KA0VXUhIKMjAyNi0wNC0wMxoDTlJUKgJVQTICNzlqDQgDEgkvbS8wMl8yODZyDAgDEggvbS8wN2RmaxpJEgoyMDI2LTA0LTE3Ih4KA05SVBIKMjAyNi0wNC0xNxoDRVdSKgJVQTICNzhqDAgDEggvbS8wN2Rma3INCAMSCS9tLzAyXzI4NkABSAJwAYIBCwj___________8BmAEB&amp;tfu=CmxDalJJYWtNNU9GTkdXblUyVWxsQlJGUnFkMUZDUnkwdExTMHRMUzEyZDI0eU9DMXVNa0ZCUVVGQlIyMUhTMnd3VEdOV1FrMUJFZ1JWUVRjNEdnc0l5ZG9VRUFJYUExVlRSRGdjY01uYUZBPT0SAggAIgYKATAKATE'}</pre> <p>This returns a nonstop flight on United.</p> <p>The <code>'price_classification'</code> and <code>'price_difference'</code> here are <code>None</code>. I've found that Google Flights offers these suggestions less for non-Economy flights.</p> In\u00a0[6]: Copied! <pre># Initialize\nscraper = GoogleFlightsScraper()\n\n# Create Dates\nstart = (today + timedelta(weeks=6)).strftime(\"%m/%d/%Y\")\nend = (today + timedelta(weeks=7)).strftime(\"%m/%d/%Y\")\n\n# Run\nresult = scraper.scrape_flight(\n    departure_code=\"SFO\",\n    departure_country=\"United States of America\",\n    arrival_code=\"DCA\",\n    arrival_country=\"United States of America\",\n    start_date=start,\n    end_date=end,\n    seat_class=\"Economy (exclude Basic)\",\n)\nresult\n</pre> # Initialize scraper = GoogleFlightsScraper()  # Create Dates start = (today + timedelta(weeks=6)).strftime(\"%m/%d/%Y\") end = (today + timedelta(weeks=7)).strftime(\"%m/%d/%Y\")  # Run result = scraper.scrape_flight(     departure_code=\"SFO\",     departure_country=\"United States of America\",     arrival_code=\"DCA\",     arrival_country=\"United States of America\",     start_date=start,     end_date=end,     seat_class=\"Economy (exclude Basic)\", ) result Out[6]: <pre>{'inputs': {'departure_airport': 'SFO',\n  'departure_country': 'United States of America',\n  'arrival_airport': 'DCA',\n  'arrival_country': 'United States of America',\n  'departure_date': '03/20/2026',\n  'return_date': '03/27/2026',\n  'seat_class': 'Economy (exclude Basic)'},\n 'departure_flight': {'airline': 'Southwest',\n  'departure_airport': 'San Francisco International Airport',\n  'departure_date': 'Friday, March 20',\n  'departure_time': '5:10 AM',\n  'num_stops': 1,\n  'connection_airports': ['Chicago Midway International Airport'],\n  'layover_durations': ['1 hr'],\n  'arrival_airport': 'Ronald Reagan Washington National Airport',\n  'arrival_date': 'Friday, March 20',\n  'arrival_time': '2:55 PM',\n  'duration_minutes': 405,\n  'duration_str': '6 hr 45 min',\n  'carry_on_bags': 1,\n  'checked_bags': 0},\n 'return_flight': {'airline': 'Southwest',\n  'departure_airport': 'Ronald Reagan Washington National Airport',\n  'departure_date': 'Friday, March 27',\n  'departure_time': '9:05 AM',\n  'num_stops': 1,\n  'connection_airports': ['Nashville International Airport'],\n  'layover_durations': ['2 hr 10 min'],\n  'arrival_airport': 'San Francisco International Airport',\n  'arrival_date': 'Friday, March 27',\n  'arrival_time': '3:25 PM',\n  'duration_minutes': 560,\n  'duration_str': '9 hr 20 min',\n  'carry_on_bags': 1,\n  'checked_bags': 0},\n 'price': 708,\n 'price_classification': 'typical',\n 'price_difference': 0,\n 'price_relativity': 0.0,\n 'status': 'Ran successfully.',\n 'url': 'https://www.google.com/travel/flights/booking?tfs=CBwQAhphEgoyMDI2LTAzLTIwIiAKA1NGTxIKMjAyNi0wMy0yMBoDTURXKgJXTjIEMzkzOCIfCgNNRFcSCjIwMjYtMDMtMjAaA0RDQSoCV04yAzE2NGoHCAESA1NGT3IHCAESA0RDQRpgEgoyMDI2LTAzLTI3Ih8KA0RDQRIKMjAyNi0wMy0yNxoDQk5BKgJXTjIDOTY1Ih8KA0JOQRIKMjAyNi0wMy0yNxoDU0ZPKgJXTjIDNjc4agcIARIDRENBcgcIARIDU0ZPQAFIAXABggELCP___________wGYAQHIAQE&amp;tfu=CnRDalJJVkY5R2QxRndNRTFpTkc5QlJHUm1ORUZDUnkwdExTMHRMUzB0TFhaMGJXNHhPVUZCUVVGQlIyMUhTMjV2UzBkbWFrdEJFZ3RYVGprMk5YeFhUalkzT0JvTENOV29CQkFDR2dOVlUwUTRISERWcUFRPRICCAAiAA'}</pre> <p>This returns a flight on Southwest with one layover. You can see the layover details listed, include location and duration.</p> <p>The <code>'price_classification'</code> is 'typucal' so a <code>'price_difference'</code> of $0 is returned.</p>"},{"location":"tutorial/simple_request/#tutorial-simple-flight-request","title":"Tutorial: Simple Flight Request\u00b6","text":"<p>The <code>google_flights_scraper</code> package can be used to simulate and end-to-end process of selecting the best departure and return flight as determined and listed by Google Flights.</p>"},{"location":"tutorial/simple_request/#set-up","title":"Set Up\u00b6","text":""},{"location":"tutorial/simple_request/#request-format","title":"Request Format\u00b6","text":""},{"location":"tutorial/simple_request/#example-1-domestic-economy","title":"Example 1: Domestic Economy\u00b6","text":"<p>Below is an example request for a Domestic Economy flight leaving from LAX and arriving at one of the New York airports.</p> <p>Typical wait time is ~20 seconds.</p>"},{"location":"tutorial/simple_request/#example-2-international-premium-economy","title":"Example 2: International Premium Economy\u00b6","text":"<p>Below is an example request for a International Premium Economy flight leaving from New York and arriving in Tokyo.</p>"},{"location":"tutorial/simple_request/#example-3-domestic-economy-excluding-basic","title":"Example 3: Domestic Economy (excluding Basic)\u00b6","text":"<p>Below is an example request for a Domestic Economy (excluding Basic) flight leaving from SFO and arriving at DCA.</p> <p>Economy (excluding Basic) excludes budget airlines like Frontier, Spirit, and Breeze from its listings.</p>"}]}